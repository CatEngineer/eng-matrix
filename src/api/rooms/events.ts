/* eslint-disable @typescript-eslint/no-unsafe-assignment */
import { Entity, Manager } from "../../core/index.js";
import type { Room, RoomMember } from "../../index.js";
import type { MxApi } from "../api.js";

/** @internal */
export type AnyMxEvent<T> = MxEvent<T> | MxStateEvent<T>;

type Content<T> = Exclude<T & Record<string, any>, any[]>;

type EventConstructData = MxApi.ClientEventWithoutRoomID2;

export type RoomMemberStateContent = {
    membership?: string;
    displayname?: string;
    avatar_url?: string;
};

export type RoomMemberState = MxStateEvent<RoomMemberStateContent>;

export class MxEvent<T> extends Entity<EventManager> {
    /** @internal */
    public readonly data: EventConstructData;

    public readonly content: Content<T>;

    public readonly unsigned: Record<string, any> & {
        /**
         * The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is.
         * @format int64
         * @example 1567437
         */
        age?: number;

        /**
         * EventContent
         * The previous `content` for this event. This field is generated
         * by the local homeserver, and is only returned if the event is a state event,
         * and the client has permission to see the previous content.
         */
        previous?: MxEvent<T>;

        /**
         * The event that redacted this event, if any.
         * @example {"content":{"reason":"spam"},"event_id":"$Nhl3rsgHMjk-DjMJANawr9HHAhLg4GcoTYrSiYYGqEE","origin_server_ts":1632491098485,"redacts":"$26RqwJMLw-yds1GAH_QxjHRC1Da9oasK0e5VLnck_45","sender":"@moderator:example.org","type":"m.room.redaction","unsigned":{"age":1257}}
         */
        redacted?: RedactedEvent;

        /**
         * The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
         * `PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
         * if the client being given the event is the same one which sent it.
         */
        transactionId?: string;
    };

    public readonly type: string;

    /** @internal */
    constructor(manager: EventManager, raw: EventConstructData) {
        super(manager, raw.event_id);
        this.data = raw;
        this.content = raw.content as Content<T>;
        this.unsigned = {
            ...raw.unsigned,
            age: raw.unsigned?.age,
            previous:
                raw.unsigned?.prev_content === undefined
                    ? undefined
                    : new MxEvent(
                          manager,
                          raw.unsigned.prev_content as EventConstructData
                      ),
            redacted:
                raw.unsigned?.redacted_because === undefined
                    ? undefined
                    : new RedactedEvent(
                          manager,
                          raw.unsigned.redacted_because as EventConstructData
                      ),
            transactionId: raw.unsigned?.transaction_id,
        };
        this.type = raw.type;
    }

    public async getAuthor(): Promise<RoomMember> {
        const room = this.getRoom();
        return room.members.getMember(this.data.sender);
    }

    public async redact(reason?: string): Promise<void> {
        await this.manager.redact(this.id, reason);
    }

    public getRoom(): Room {
        return this.manager.room;
    }

    // eslint-disable-next-line @typescript-eslint/naming-convention
    public toJSON(): any {
        return this.data;
    }
}

export class MxStateEvent<T> extends MxEvent<T> {
    public readonly stateKey: string;

    /** @internal */
    constructor(manager: EventManager, raw: EventConstructData) {
        super(manager, raw);
        this.stateKey = raw.state_key ?? "";
    }

    public async getReplaces(): Promise<MxStateEvent<T> | undefined> {
        const replaces = this.unsigned?.replaces_state;
        if (!replaces) return;
        const replacesId = replaces as string;
        const result = await this.manager.getEvent<T>(replacesId);
        return result as MxStateEvent<T>;
    }
}

export class EventManager extends Manager<string, AnyMxEvent<any>> {
    constructor(public readonly room: Room) {
        super(room.client, "events");
    }

    public async getEvent<T>(id: string): Promise<AnyMxEvent<T>> {
        const cached = await this.getCachedEvent(id);
        if (cached) return cached as MxStateEvent<T>;

        const resp = await this.rest.getOneRoomEvent(this.room.id, id);
        const result = resp.state_key
            ? new MxStateEvent<T>(this, resp)
            : new MxEvent<T>(this, resp);

        await this.cacheEvent(result);
        return result;
    }

    public async getState<T>(
        type: string,
        stateKey = ""
    ): Promise<MxStateEvent<T>> {
        const cached = await this.getCachedStateEvent(type, stateKey);
        if (cached) return cached as MxStateEvent<T>;

        const states = await this.getRoomState();
        let result: MxStateEvent<T> | undefined;
        for (const state of states) {
            if (state.data.type === type && state.stateKey === stateKey) {
                result = state;
                break;
            }
        }

        if (!result) {
            throw new Error("State event not found");
        }

        await this.cacheStateEvent(result);
        return result;
    }

    public async getRoomState<T = any>(): Promise<Array<MxStateEvent<T>>>;
    public async getRoomState<T>(type: string): Promise<Array<MxStateEvent<T>>>;
    public async getRoomState<T = any>(
        type?: string
    ): Promise<Array<MxStateEvent<T>>> {
        // eslint-disable-next-line no-warning-comments
        // TODO(dylhack): cache this
        const resp = await this.rest.getRoomState(this.room.id);
        const events = resp.map((data) => new MxStateEvent<any>(this, data));
        if (type) {
            return events.filter((event) => event.data.type === type);
        }

        return events;
    }

    public async redact(id: string, reason?: string): Promise<void> {
        const txId = this.util.getTxId();
        await this.rest.redactEvent(this.room.id, id, txId, { reason });
    }

    public async sendEvent<T>(type: string, content: Content<T>): Promise<string> {
        const txId = this.util.getTxId();
        const resp = await this.rest.sendMessage(
            this.room.id,
            type,
            txId,
            content
        );
        return resp.event_id;
    }

    public async setState<T>(
        type: string,
        stateKey = "",
        content?: Content<T>
    ): Promise<string> {
        const resp = await this.rest.setRoomStateWithKey(
            this.room.id,
            type,
            stateKey,
            content ?? {}
        );
        return resp.event_id;
    }

    public async sendText(message: string): Promise<string> {
        const messageType = this.client.options.botDisclosure
            ? "m.notice"
            : "m.text";
        return this.sendEvent("m.room.message", {
            msgtype: messageType,
            body: message,
        });
    }

    public async sendMarkdown(message: string): Promise<string> {
        const messageType = this.client.options.botDisclosure
            ? "m.notice"
            : "m.text";
        return this.sendEvent("m.room.message", {
            msgtype: messageType,
            format: "org.matrix.custom.html",
            body: message,
            // eslint-disable-next-line @typescript-eslint/naming-convention
            formatted_body: this.util.mdToHtml(message),
        });
    }

    /** @internal */
    // eslint-disable-next-line @typescript-eslint/naming-convention
    public fromJSON<T>(data: string): AnyMxEvent<T> {
        const raw = JSON.parse(data) as EventConstructData;
        if (raw.state_key) return new MxStateEvent(this, raw);
        return new MxEvent(this, raw);
    }

    /** @internal */
    public async cacheEvent<T>(event: MxEvent<T>): Promise<void> {
        const cache = await this.getCache();
        await cache.set(event.id, event);
    }

    /** @internal */
    public async cacheStateEvent<T>(event: MxStateEvent<T>): Promise<void> {
        const cache = await this.getCache();
        await cache.set(`${event.type}:${event.stateKey}`, event);
    }

    private async getCachedStateEvent<T>(
        type: string,
        stateKey = ""
    ): Promise<MxStateEvent<T> | undefined> {
        const cache = await this.getCache();
        const key = `${type}:${stateKey}`;
        const cached = await cache.get(key);
        if (cached) return cached as MxStateEvent<T>;
        return undefined;
    }

    private async getCachedEvent<T>(id: string): Promise<MxEvent<T> | undefined> {
        const cache = await this.getCache();
        const cached = await cache.get(id);
        if (cached) return cached as MxEvent<T>;
        return undefined;
    }
}

export class RedactedEvent extends MxEvent<{ reason?: string }> {}
