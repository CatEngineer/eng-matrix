/* eslint-disable */
/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.0.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export module MxApi {

export class MxHttpClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://matrix.org/";
    }

    /**
     * Gets Matrix server discovery information about the domain.
     * @return Server discovery information.
     */
    getWellknown(): Promise<Anonymous> {
        let url_ = this.baseUrl + "/.well-known/matrix/client";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWellknown(_response);
        });
    }

    protected processGetWellknown(response: Response): Promise<Anonymous> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("No server discovery information available.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous>(null as any);
    }

    /**
     * Query if a given registration token is still valid.
     * @param token The token to check validity of.
     * @return The check has a result.
     */
    registrationTokenValidity(token: string): Promise<Anonymous2> {
        let url_ = this.baseUrl + "/_matrix/client/v1/register/m.login.registration_token/validity?";
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined and cannot be null.");
        else
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegistrationTokenValidity(_response);
        });
    }

    protected processRegistrationTokenValidity(response: Response): Promise<Anonymous2> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous2;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorDto;
            return throwException("The homeserver does not permit registration and thus all tokens are\nconsidered invalid.", status, _responseText, _headers, result403);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous2>(null as any);
    }

    /**
     * Retrieve a portion of a space tree.
     * @param roomId The room ID of the space to get a hierarchy for.
     * @param suggested_only (optional) Optional (default `false`) flag to indicate whether or not the server should only consider
    suggested rooms. Suggested rooms are annotated in their [`m.space.child`](#mspacechild) event
    contents.
     * @param limit (optional) Optional limit for the maximum number of rooms to include per response. Must be an integer
    greater than zero.

    Servers should apply a default value, and impose a maximum value to avoid resource exhaustion.
     * @param max_depth (optional) Optional limit for how far to go into the space. Must be a non-negative integer.

    When reached, no further child rooms will be returned.

    Servers should apply a default value, and impose a maximum value to avoid resource exhaustion.
     * @param from (optional) A pagination token from a previous result. If specified, `max_depth` and `suggested_only` cannot
    be changed from the first request.
     * @return A portion of the space tree, starting at the provided room ID.
     */
    getSpaceHierarchy(roomId: string, suggested_only?: boolean | null | undefined, limit?: number | null | undefined, max_depth?: number | null | undefined, from?: string | null | undefined): Promise<Anonymous3> {
        let url_ = this.baseUrl + "/_matrix/client/v1/rooms/{roomId}/hierarchy?";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        if (suggested_only !== undefined && suggested_only !== null)
            url_ += "suggested_only=" + encodeURIComponent("" + suggested_only) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (max_depth !== undefined && max_depth !== null)
            url_ += "max_depth=" + encodeURIComponent("" + max_depth) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSpaceHierarchy(_response);
        });
    }

    protected processGetSpaceHierarchy(response: Response): Promise<Anonymous3> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous3;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error;
            return throwException("The request was invalid in some way. A meaningful `errcode`\nand description error text will be returned. Example reasons for rejection are:\n\n- The `from` token is unknown to the server.\n- `suggested_only` or `max_depth` changed during pagination.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error2;
            return throwException("The user cannot view or peek on the room. A meaningful `errcode`\nand description error text will be returned. Example reasons for rejection are:\n\n- The room is not set up for peeking.\n- The user has been banned from the room.\n- The room does not exist.", status, _responseText, _headers, result403);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError2;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous3>(null as any);
    }

    /**
     * Get the child events for a given parent event.
     * @param roomId The ID of the room containing the parent event.
     * @param eventId The ID of the parent event whose child events are to be returned.
     * @param from (optional) The pagination token to start returning results from. If not supplied, results
    start at the most recent topological event known to the server.

    Can be a `next_batch` or `prev_batch` token from a previous call, or a returned
    `start` token from [`/messages`](https://spec.matrix.org/v1.5/client-server-api/#get_matrixclientv3roomsroomidmessages),
    or a `next_batch` token from [`/sync`](https://spec.matrix.org/v1.5/client-server-api/#get_matrixclientv3sync).
     * @param to (optional) The pagination token to stop returning results at. If not supplied, results
    continue up to `limit` or until there are no more events.

    Like `from`, this can be a previous token from a prior call to this endpoint
    or from `/messages` or `/sync`.
     * @param limit (optional) The maximum number of results to return in a single `chunk`. The server can
    and should apply a maximum value to this parameter to avoid large responses.

    Similarly, the server should apply a default value when not supplied.
     * @param dir (optional) Optional (default `b`) direction to return events from. If this is set to `f`, events
    will be returned in chronological order starting at `from`. If it
    is set to `b`, events will be returned in *reverse* chronological
    order, again starting at `from`.
     * @return The paginated child events which point to the parent. If no events are
    pointing to the parent or the pagination yields no results, an empty `chunk`
    is returned.
     */
    getRelatingEvents(roomId: string, eventId: string, from?: string | null | undefined, to?: string | null | undefined, limit?: number | null | undefined, dir?: Dir | null | undefined): Promise<Anonymous4> {
        let url_ = this.baseUrl + "/_matrix/client/v1/rooms/{roomId}/relations/{eventId}?";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (dir !== undefined && dir !== null)
            url_ += "dir=" + encodeURIComponent("" + dir) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRelatingEvents(_response);
        });
    }

    protected processGetRelatingEvents(response: Response): Promise<Anonymous4> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous4;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error3;
            return throwException("The parent event was not found or the user does not have permission to read\nthis event (it might be contained in history that is not accessible to the user).", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous4>(null as any);
    }

    /**
     * Get the child events for a given parent event, with a given `relType`.
     * @param roomId The ID of the room containing the parent event.
     * @param eventId The ID of the parent event whose child events are to be returned.
     * @param relType The [relationship type](https://spec.matrix.org/v1.5/client-server-api/#relationship-types) to search for.
     * @param from (optional) The pagination token to start returning results from. If not supplied, results
    start at the most recent topological event known to the server.

    Can be a `next_batch` or `prev_batch` token from a previous call, or a returned
    `start` token from [`/messages`](https://spec.matrix.org/v1.5/client-server-api/#get_matrixclientv3roomsroomidmessages),
    or a `next_batch` token from [`/sync`](https://spec.matrix.org/v1.5/client-server-api/#get_matrixclientv3sync).
     * @param to (optional) The pagination token to stop returning results at. If not supplied, results
    continue up to `limit` or until there are no more events.

    Like `from`, this can be a previous token from a prior call to this endpoint
    or from `/messages` or `/sync`.
     * @param limit (optional) The maximum number of results to return in a single `chunk`. The server can
    and should apply a maximum value to this parameter to avoid large responses.

    Similarly, the server should apply a default value when not supplied.
     * @param dir (optional) Optional (default `b`) direction to return events from. If this is set to `f`, events
    will be returned in chronological order starting at `from`. If it
    is set to `b`, events will be returned in *reverse* chronological
    order, again starting at `from`.
     * @return The paginated child events which point to the parent. If no events are
    pointing to the parent or the pagination yields no results, an empty `chunk`
    is returned.
     */
    getRelatingEventsWithRelType(roomId: string, eventId: string, relType: string, from?: string | null | undefined, to?: string | null | undefined, limit?: number | null | undefined, dir?: Dir2 | null | undefined): Promise<Anonymous5> {
        let url_ = this.baseUrl + "/_matrix/client/v1/rooms/{roomId}/relations/{eventId}/{relType}?";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        if (relType === undefined || relType === null)
            throw new Error("The parameter 'relType' must be defined.");
        url_ = url_.replace("{relType}", encodeURIComponent("" + relType));
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (dir !== undefined && dir !== null)
            url_ += "dir=" + encodeURIComponent("" + dir) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRelatingEventsWithRelType(_response);
        });
    }

    protected processGetRelatingEventsWithRelType(response: Response): Promise<Anonymous5> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous5;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error4;
            return throwException("The parent event was not found or the user does not have permission to read\nthis event (it might be contained in history that is not accessible to the user).", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous5>(null as any);
    }

    /**
     * Get the child events for a given parent event, with a given `relType` and `eventType`.
     * @param roomId The ID of the room containing the parent event.
     * @param eventId The ID of the parent event whose child events are to be returned.
     * @param relType The [relationship type](https://spec.matrix.org/v1.5/client-server-api/#relationship-types) to search for.
     * @param eventType The event type of child events to search for.

    Note that in encrypted rooms this will typically always be `m.room.encrypted`
    regardless of the event type contained within the encrypted payload.
     * @param from (optional) The pagination token to start returning results from. If not supplied, results
    start at the most recent topological event known to the server.

    Can be a `next_batch` or `prev_batch` token from a previous call, or a returned
    `start` token from [`/messages`](https://spec.matrix.org/v1.5/client-server-api/#get_matrixclientv3roomsroomidmessages),
    or a `next_batch` token from [`/sync`](https://spec.matrix.org/v1.5/client-server-api/#get_matrixclientv3sync).
     * @param to (optional) The pagination token to stop returning results at. If not supplied, results
    continue up to `limit` or until there are no more events.

    Like `from`, this can be a previous token from a prior call to this endpoint
    or from `/messages` or `/sync`.
     * @param limit (optional) The maximum number of results to return in a single `chunk`. The server can
    and should apply a maximum value to this parameter to avoid large responses.

    Similarly, the server should apply a default value when not supplied.
     * @param dir (optional) Optional (default `b`) direction to return events from. If this is set to `f`, events
    will be returned in chronological order starting at `from`. If it
    is set to `b`, events will be returned in *reverse* chronological
    order, again starting at `from`.
     * @return The paginated child events which point to the parent. If no events are
    pointing to the parent or the pagination yields no results, an empty `chunk`
    is returned.
     */
    getRelatingEventsWithRelTypeAndEventType(roomId: string, eventId: string, relType: string, eventType: string, from?: string | null | undefined, to?: string | null | undefined, limit?: number | null | undefined, dir?: Dir3 | null | undefined): Promise<Anonymous6> {
        let url_ = this.baseUrl + "/_matrix/client/v1/rooms/{roomId}/relations/{eventId}/{relType}/{eventType}?";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        if (relType === undefined || relType === null)
            throw new Error("The parameter 'relType' must be defined.");
        url_ = url_.replace("{relType}", encodeURIComponent("" + relType));
        if (eventType === undefined || eventType === null)
            throw new Error("The parameter 'eventType' must be defined.");
        url_ = url_.replace("{eventType}", encodeURIComponent("" + eventType));
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (dir !== undefined && dir !== null)
            url_ += "dir=" + encodeURIComponent("" + dir) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRelatingEventsWithRelTypeAndEventType(_response);
        });
    }

    protected processGetRelatingEventsWithRelTypeAndEventType(response: Response): Promise<Anonymous6> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous6;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error5;
            return throwException("The parent event was not found or the user does not have permission to read\nthis event (it might be contained in history that is not accessible to the user).", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous6>(null as any);
    }

    /**
     * Retrieve a list of threads in a room, with optional filters.
     * @param roomId The room ID where the thread roots are located.
     * @param include (optional) Optional (default `all`) flag to denote which thread roots are of interest to the caller.
    When `all`, all thread roots found in the room are returned. When `participated`, only
    thread roots for threads the user has [participated in](https://spec.matrix.org/v1.5/client-server-api/#server-side-aggregation-of-mthread-relationships)
    will be returned.
     * @param limit (optional) Optional limit for the maximum number of thread roots to include per response. Must be an integer
    greater than zero.

    Servers should apply a default value, and impose a maximum value to avoid resource exhaustion.
     * @param from (optional) A pagination token from a previous result. When not provided, the server starts paginating from
    the most recent event visible to the user (as per history visibility rules; topologically).
     * @return A portion of the available thread roots in the room, based on the filter criteria.
     */
    getThreadRoots(roomId: string, include?: Include | null | undefined, limit?: number | null | undefined, from?: string | null | undefined): Promise<Anonymous7> {
        let url_ = this.baseUrl + "/_matrix/client/v1/rooms/{roomId}/threads?";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        if (include !== undefined && include !== null)
            url_ += "include=" + encodeURIComponent("" + include) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetThreadRoots(_response);
        });
    }

    protected processGetThreadRoots(response: Response): Promise<Anonymous7> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous7;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error6;
            return throwException("The request was invalid in some way. A meaningful `errcode`\nand description error text will be returned. Example reasons for rejection are:\n\n- The `from` token is unknown to the server.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error7;
            return throwException("The user cannot view or peek on the room. A meaningful `errcode`\nand description error text will be returned. Example reasons for rejection are:\n\n- The room is not set up for peeking.\n- The user has been banned from the room.\n- The room does not exist.", status, _responseText, _headers, result403);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError3;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous7>(null as any);
    }

    /**
     * Gets a list of a user's third party identifiers.
     * @return The lookup was successful.
     */
    getAccount3PIDs(): Promise<Anonymous8> {
        let url_ = this.baseUrl + "/_matrix/client/v3/account/3pid";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAccount3PIDs(_response);
        });
    }

    protected processGetAccount3PIDs(response: Response): Promise<Anonymous8> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous8;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous8>(null as any);
    }

    /**
     * Adds contact information to the user's account.
     * @return The addition was successful.
     * @deprecated
     */
    post3PIDs(body: Body): Promise<Anonymous9> {
        let url_ = this.baseUrl + "/_matrix/client/v3/account/3pid";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost3PIDs(_response);
        });
    }

    protected processPost3PIDs(response: Response): Promise<Anonymous9> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous9;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error8;
            return throwException("The credentials could not be verified with the identity server.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous9>(null as any);
    }

    /**
     * Adds contact information to the user's account.
     * @return The addition was successful.
     */
    add3PID(body: Body2): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/account/3pid/add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAdd3PID(_response);
        });
    }

    protected processAdd3PID(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous10;
            return throwException("The homeserver requires additional authentication information.", status, _responseText, _headers, result401);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError4;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Binds a 3PID to the user's account through an Identity Service.
     * @return The addition was successful.
     */
    bind3PID(body: Body3): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/account/3pid/bind";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBind3PID(_response);
        });
    }

    protected processBind3PID(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError5;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Deletes a third party identifier from the user's account
     * @return The homeserver has disassociated the third party identifier from the
    user.
     */
    delete3pidFromAccount(body: Body4): Promise<Anonymous11> {
        let url_ = this.baseUrl + "/_matrix/client/v3/account/3pid/delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete3pidFromAccount(_response);
        });
    }

    protected processDelete3pidFromAccount(response: Response): Promise<Anonymous11> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous11;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous11>(null as any);
    }

    /**
     * Begins the validation process for an email address for association with the user's account.
     * @return An email was sent to the given address. Note that this may be an
    email containing the validation token or it may be informing the
    user of an error.
     */
    requestTokenTo3PIDEmail(body: Body5): Promise<RequestTokenResponse> {
        let url_ = this.baseUrl + "/_matrix/client/v3/account/3pid/email/requestToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestTokenTo3PIDEmail(_response);
        });
    }

    protected processRequestTokenTo3PIDEmail(response: Response): Promise<RequestTokenResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RequestTokenResponse;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error9;
            return throwException("The third party identifier is already in use on the homeserver, or\nthe request was invalid. The error code `M_SERVER_NOT_TRUSTED`\ncan be returned if the server does not trust/support the identity server\nprovided in the request.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error10;
            return throwException("The homeserver does not allow the third party identifier as a\ncontact option.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RequestTokenResponse>(null as any);
    }

    /**
     * Begins the validation process for a phone number for association with the user's account.
     * @return An SMS message was sent to the given phone number.
     */
    requestTokenTo3PIDMSISDN(body: Body6): Promise<RequestTokenResponse2> {
        let url_ = this.baseUrl + "/_matrix/client/v3/account/3pid/msisdn/requestToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestTokenTo3PIDMSISDN(_response);
        });
    }

    protected processRequestTokenTo3PIDMSISDN(response: Response): Promise<RequestTokenResponse2> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RequestTokenResponse2;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error11;
            return throwException("The third party identifier is already in use on the homeserver, or\nthe request was invalid. The error code `M_SERVER_NOT_TRUSTED`\ncan be returned if the server does not trust/support the identity server\nprovided in the request.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error12;
            return throwException("The homeserver does not allow the third party identifier as a\ncontact option.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RequestTokenResponse2>(null as any);
    }

    /**
     * Removes a user's third party identifier from an identity server.
     * @return The identity server has disassociated the third party identifier from the
    user.
     */
    unbind3pidFromAccount(body: Body7): Promise<Anonymous12> {
        let url_ = this.baseUrl + "/_matrix/client/v3/account/3pid/unbind";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnbind3pidFromAccount(_response);
        });
    }

    protected processUnbind3pidFromAccount(response: Response): Promise<Anonymous12> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous12;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous12>(null as any);
    }

    /**
     * Deactivate a user's account.
     * @return The account has been deactivated.
     */
    deactivateAccount(body: Body8): Promise<Anonymous13> {
        let url_ = this.baseUrl + "/_matrix/client/v3/account/deactivate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeactivateAccount(_response);
        });
    }

    protected processDeactivateAccount(response: Response): Promise<Anonymous13> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous13;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous14;
            return throwException("The homeserver requires additional authentication information.", status, _responseText, _headers, result401);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError6;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous13>(null as any);
    }

    /**
     * Changes a user's password.
     * @return The password has been changed.
     */
    changePassword(body: Body9): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/account/password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangePassword(_response);
        });
    }

    protected processChangePassword(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous15;
            return throwException("The homeserver requires additional authentication information.", status, _responseText, _headers, result401);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError7;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Requests a validation token be sent to the given email address for the purpose of resetting a user's password
     * @return An email was sent to the given address.
     */
    requestTokenToResetPasswordEmail(body: Body10): Promise<RequestTokenResponse3> {
        let url_ = this.baseUrl + "/_matrix/client/v3/account/password/email/requestToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestTokenToResetPasswordEmail(_response);
        });
    }

    protected processRequestTokenToResetPasswordEmail(response: Response): Promise<RequestTokenResponse3> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RequestTokenResponse3;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error13;
            return throwException("The referenced third party identifier is not recognised by the\nhomeserver, or the request was invalid. The error code `M_SERVER_NOT_TRUSTED`\ncan be returned if the server does not trust/support the identity server\nprovided in the request.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error14;
            return throwException("The homeserver does not allow the third party identifier as a\ncontact option.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RequestTokenResponse3>(null as any);
    }

    /**
     * Requests a validation token be sent to the given phone number for the purpose of resetting a user's password.
     * @return An SMS message was sent to the given phone number.
     */
    requestTokenToResetPasswordMSISDN(body: Body11): Promise<RequestTokenResponse4> {
        let url_ = this.baseUrl + "/_matrix/client/v3/account/password/msisdn/requestToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestTokenToResetPasswordMSISDN(_response);
        });
    }

    protected processRequestTokenToResetPasswordMSISDN(response: Response): Promise<RequestTokenResponse4> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RequestTokenResponse4;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error15;
            return throwException("The referenced third party identifier is not recognised by the\nhomeserver, or the request was invalid. The error code `M_SERVER_NOT_TRUSTED`\ncan be returned if the server does not trust/support the identity server\nprovided in the request.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error16;
            return throwException("The homeserver does not allow the third party identifier as a\ncontact option.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RequestTokenResponse4>(null as any);
    }

    /**
     * Gets information about the owner of an access token.
     * @return The token belongs to a known user.
     */
    getTokenOwner(): Promise<Anonymous16> {
        let url_ = this.baseUrl + "/_matrix/client/v3/account/whoami";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTokenOwner(_response);
        });
    }

    protected processGetTokenOwner(response: Response): Promise<Anonymous16> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous16;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error17;
            return throwException("The token is not recognised", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error18;
            return throwException("The appservice cannot masquerade as the user or has not registered them.", status, _responseText, _headers, result403);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError8;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous16>(null as any);
    }

    /**
     * Gets information about a particular user.
     * @param userId The user to look up.
     * @return The lookup was successful.
     */
    getWhoIs(userId: string): Promise<Anonymous17> {
        let url_ = this.baseUrl + "/_matrix/client/v3/admin/whois/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetWhoIs(_response);
        });
    }

    protected processGetWhoIs(response: Response): Promise<Anonymous17> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous17;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous17>(null as any);
    }

    /**
     * Gets information about the server's capabilities.
     * @return The capabilities of the server.
     */
    getCapabilities(): Promise<Anonymous18> {
        let url_ = this.baseUrl + "/_matrix/client/v3/capabilities";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCapabilities(_response);
        });
    }

    protected processGetCapabilities(response: Response): Promise<Anonymous18> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous18;
            return result200;
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError9;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous18>(null as any);
    }

    /**
     * Create a new room
     * @param body The desired room configuration.
     * @return Information about the newly created room.
     */
    createRoom(body: Body12): Promise<Anonymous19> {
        let url_ = this.baseUrl + "/_matrix/client/v3/createRoom";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateRoom(_response);
        });
    }

    protected processCreateRoom(response: Response): Promise<Anonymous19> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous19;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error19;
            return throwException("\nThe request is invalid. A meaningful `errcode` and description\nerror text will be returned. Example reasons for rejection include:\n\n- The request body is malformed (`errcode` set to `M_BAD_JSON`\n  or `M_NOT_JSON`).\n\n- The room alias specified is already taken (`errcode` set to\n  `M_ROOM_IN_USE`).\n\n- The initial state implied by the parameters to the request is\n  invalid: for example, the user\'s `power_level` is set below\n  that necessary to set the room name (`errcode` set to\n  `M_INVALID_ROOM_STATE`).\n\n- The homeserver doesn\'t support the requested room version, or\n  one or more users being invited to the new room are residents\n  of a homeserver which does not support the requested room version.\n  The `errcode` will be `M_UNSUPPORTED_ROOM_VERSION` in these\n  cases.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous19>(null as any);
    }

    /**
     * Bulk deletion of devices
     * @return The devices were successfully removed, or had been removed
    previously.
     */
    deleteDevices(body: Body13): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/delete_devices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDevices(_response);
        });
    }

    protected processDeleteDevices(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous20;
            return throwException("The homeserver requires additional authentication information.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * List registered devices for the current user
     * @return Device information
     */
    getDevices(): Promise<Anonymous21> {
        let url_ = this.baseUrl + "/_matrix/client/v3/devices";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDevices(_response);
        });
    }

    protected processGetDevices(response: Response): Promise<Anonymous21> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous21;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous21>(null as any);
    }

    /**
     * Delete a device
     * @param deviceId The device to delete.
     * @return The device was successfully removed, or had been removed
    previously.
     */
    deleteDevice(deviceId: string, body: Body14): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/devices/{deviceId}";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteDevice(_response);
        });
    }

    protected processDeleteDevice(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous22;
            return throwException("The homeserver requires additional authentication information.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Get a single device
     * @param deviceId The device to retrieve.
     * @return Device information
     */
    getDevice(deviceId: string): Promise<Anonymous23> {
        let url_ = this.baseUrl + "/_matrix/client/v3/devices/{deviceId}";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDevice(_response);
        });
    }

    protected processGetDevice(response: Response): Promise<Anonymous23> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous23;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("The current user has no device with the given ID.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous23>(null as any);
    }

    /**
     * Update a device
     * @param deviceId The device to update.
     * @param body New information for the device.
     * @return The device was successfully updated.
     */
    updateDevice(deviceId: string, body: Body15): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/devices/{deviceId}";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateDevice(_response);
        });
    }

    protected processUpdateDevice(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("The current user has no device with the given ID.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Updates a room's visibility in the application service's room directory.
     * @param networkId The protocol (network) ID to update the room list for. This would
    have been provided by the application service as being listed as
    a supported protocol.
     * @param roomId The room ID to add to the directory.
     * @return The room's directory visibility has been updated.
     */
    updateAppserviceRoomDirectoryVisibility(networkId: string, roomId: string, body: Body16): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/directory/list/appservice/{networkId}/{roomId}";
        if (networkId === undefined || networkId === null)
            throw new Error("The parameter 'networkId' must be defined.");
        url_ = url_.replace("{networkId}", encodeURIComponent("" + networkId));
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateAppserviceRoomDirectoryVisibility(_response);
        });
    }

    protected processUpdateAppserviceRoomDirectoryVisibility(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Gets the visibility of a room in the directory
     * @param roomId The room ID.
     * @return The visibility of the room in the directory
     */
    getRoomVisibilityOnDirectory(roomId: string): Promise<Anonymous24> {
        let url_ = this.baseUrl + "/_matrix/client/v3/directory/list/room/{roomId}";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRoomVisibilityOnDirectory(_response);
        });
    }

    protected processGetRoomVisibilityOnDirectory(response: Response): Promise<Anonymous24> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous24;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error20;
            return throwException("The room is not known to the server", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous24>(null as any);
    }

    /**
     * Sets the visibility of a room in the room directory
     * @param roomId The room ID.
     * @param body The new visibility for the room on the room directory.
     * @return The visibility was updated, or no change was needed.
     */
    setRoomVisibilityOnDirectory(roomId: string, body: Body17): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/directory/list/room/{roomId}";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetRoomVisibilityOnDirectory(_response);
        });
    }

    protected processSetRoomVisibilityOnDirectory(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error21;
            return throwException("The room is not known to the server", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Remove a mapping of room alias to room ID.
     * @param roomAlias The room alias to remove. Its format is defined
    [in the appendices](https://spec.matrix.org/v1.5/appendices/#room-aliases).
     * @return The mapping was deleted.
     */
    deleteRoomAlias(roomAlias: string): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/directory/room/{roomAlias}";
        if (roomAlias === undefined || roomAlias === null)
            throw new Error("The parameter 'roomAlias' must be defined.");
        url_ = url_.replace("{roomAlias}", encodeURIComponent("" + roomAlias));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRoomAlias(_response);
        });
    }

    protected processDeleteRoomAlias(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error22;
            return throwException("There is no mapped room ID for this room alias.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Get the room ID corresponding to this room alias.
     * @param roomAlias The room alias. Its format is defined
    [in the appendices](https://spec.matrix.org/v1.5/appendices/#room-aliases).
     * @return The room ID and other information for this alias.
     */
    getRoomIdByAlias(roomAlias: string): Promise<Anonymous25> {
        let url_ = this.baseUrl + "/_matrix/client/v3/directory/room/{roomAlias}";
        if (roomAlias === undefined || roomAlias === null)
            throw new Error("The parameter 'roomAlias' must be defined.");
        url_ = url_.replace("{roomAlias}", encodeURIComponent("" + roomAlias));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRoomIdByAlias(_response);
        });
    }

    protected processGetRoomIdByAlias(response: Response): Promise<Anonymous25> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous25;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error23;
            return throwException("The given `roomAlias` is not a valid room alias.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error24;
            return throwException("There is no mapped room ID for this room alias.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous25>(null as any);
    }

    /**
     * Create a new mapping from room alias to room ID.
     * @param roomAlias The room alias to set. Its format is defined
    [in the appendices](https://spec.matrix.org/v1.5/appendices/#room-aliases).
     * @param body Information about this room alias.
     * @return The mapping was created.
     */
    setRoomAlias(roomAlias: string, body: Body18): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/directory/room/{roomAlias}";
        if (roomAlias === undefined || roomAlias === null)
            throw new Error("The parameter 'roomAlias' must be defined.");
        url_ = url_.replace("{roomAlias}", encodeURIComponent("" + roomAlias));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetRoomAlias(_response);
        });
    }

    protected processSetRoomAlias(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error25;
            return throwException("The given `roomAlias` is not a valid room alias.", status, _responseText, _headers, result400);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error26;
            return throwException("A room alias with that name already exists.", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Listen on the event stream.
     * @param from (optional) The token to stream from. This token is either from a previous
    request to this API or from the initial sync API.
     * @param timeout (optional) The maximum time in milliseconds to wait for an event.
     * @return The events received, which may be none.
     * @deprecated
     */
    getEvents(from?: string | null | undefined, timeout?: number | null | undefined): Promise<Anonymous26> {
        let url_ = this.baseUrl + "/_matrix/client/v3/events?";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (timeout !== undefined && timeout !== null)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEvents(_response);
        });
    }

    protected processGetEvents(response: Response): Promise<Anonymous26> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous26;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad pagination `from` parameter.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous26>(null as any);
    }

    /**
     * Listen on the event stream of a particular room.
     * @param from (optional) The token to stream from. This token is either from a previous
    request to this API or from the initial sync API.
     * @param timeout (optional) The maximum time in milliseconds to wait for an event.
     * @param room_id (optional) The room ID for which events should be returned.
     * @return The events received, which may be none.
     */
    peekEvents(from?: string | null | undefined, timeout?: number | null | undefined, room_id?: string | null | undefined): Promise<Anonymous27> {
        let url_ = this.baseUrl + "/_matrix/client/v3/events ?";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (timeout !== undefined && timeout !== null)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
        if (room_id !== undefined && room_id !== null)
            url_ += "room_id=" + encodeURIComponent("" + room_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPeekEvents(_response);
        });
    }

    protected processPeekEvents(response: Response): Promise<Anonymous27> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous27;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad pagination `from` parameter.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous27>(null as any);
    }

    /**
     * Get a single event by event ID.
     * @param eventId The event ID to get.
     * @return The full event.
     * @deprecated
     */
    getOneEvent(eventId: string): Promise<ClientEvent> {
        let url_ = this.baseUrl + "/_matrix/client/v3/events/{eventId}";
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOneEvent(_response);
        });
    }

    protected processGetOneEvent(response: Response): Promise<ClientEvent> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClientEvent;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("The event was not found or you do not have permission to read this event.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientEvent>(null as any);
    }

    /**
     * Get the user's current state.
     * @param limit (optional) The maximum number of messages to return for each room.
     * @param archived (optional) Whether to include rooms that the user has left. If `false` then
    only rooms that the user has been invited to or has joined are
    included. If set to `true` then rooms that the user has left are
    included as well. By default this is `false`.
     * @return The user's current state.
     * @deprecated
     */
    initialSync(limit?: number | null | undefined, archived?: boolean | null | undefined): Promise<Anonymous28> {
        let url_ = this.baseUrl + "/_matrix/client/v3/initialSync?";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (archived !== undefined && archived !== null)
            url_ += "archived=" + encodeURIComponent("" + archived) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInitialSync(_response);
        });
    }

    protected processInitialSync(response: Response): Promise<Anonymous28> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous28;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("There is no avatar URL for this user or this user does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous28>(null as any);
    }

    /**
     * Start the requesting user participating in a particular room.
     * @param roomIdOrAlias The room identifier or alias to join.
     * @param server_name (optional) The servers to attempt to join the room through. One of the servers
    must be participating in the room.
     * @return The room has been joined.

    The joined room ID must be returned in the `room_id` field.
     */
    joinRoom(roomIdOrAlias: string, body: Body19, server_name?: string[] | null | undefined): Promise<Anonymous29> {
        let url_ = this.baseUrl + "/_matrix/client/v3/join/{roomIdOrAlias}?";
        if (roomIdOrAlias === undefined || roomIdOrAlias === null)
            throw new Error("The parameter 'roomIdOrAlias' must be defined.");
        url_ = url_.replace("{roomIdOrAlias}", encodeURIComponent("" + roomIdOrAlias));
        if (server_name !== undefined && server_name !== null)
            server_name && server_name.forEach(item => { url_ += "server_name=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processJoinRoom(_response);
        });
    }

    protected processJoinRoom(response: Response): Promise<Anonymous29> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous29;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error27;
            return throwException("You do not have permission to join the room. A meaningful `errcode`\nand description error text will be returned. Example reasons for rejection are:\n\n- The room is invite-only and the user was not invited.\n- The user has been banned from the room.\n- The room is restricted and the user failed to satisfy any of the conditions.", status, _responseText, _headers, result403);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError10;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous29>(null as any);
    }

    /**
     * Lists the user's current rooms.
     * @return A list of the rooms the user is in.
     */
    getJoinedRooms(): Promise<Anonymous30> {
        let url_ = this.baseUrl + "/_matrix/client/v3/joined_rooms";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetJoinedRooms(_response);
        });
    }

    protected processGetJoinedRooms(response: Response): Promise<Anonymous30> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous30;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous30>(null as any);
    }

    /**
     * Query users with recent device key updates.
     * @param from The desired start point of the list. Should be the `next_batch` field
    from a response to an earlier call to [`/sync`](https://spec.matrix.org/v1.5/client-server-api/#get_matrixclientv3sync). Users who have not
    uploaded new device identity keys since this point, nor deleted
    existing devices with identity keys since then, will be excluded
    from the results.
     * @param to The desired end point of the list. Should be the `next_batch`
    field from a recent call to [`/sync`](https://spec.matrix.org/v1.5/client-server-api/#get_matrixclientv3sync) - typically the most recent
    such call. This may be used by the server as a hint to check its
    caches are up to date.
     * @return The list of users who updated their devices.
     */
    getKeysChanges(from: string, to: string): Promise<Anonymous31> {
        let url_ = this.baseUrl + "/_matrix/client/v3/keys/changes?";
        if (from === undefined || from === null)
            throw new Error("The parameter 'from' must be defined and cannot be null.");
        else
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (to === undefined || to === null)
            throw new Error("The parameter 'to' must be defined and cannot be null.");
        else
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetKeysChanges(_response);
        });
    }

    protected processGetKeysChanges(response: Response): Promise<Anonymous31> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous31;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous31>(null as any);
    }

    /**
     * Claim one-time encryption keys.
     * @param query Query defining the keys to be claimed
     * @return The claimed keys.
     */
    claimKeys(query: Query): Promise<Anonymous32> {
        let url_ = this.baseUrl + "/_matrix/client/v3/keys/claim";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processClaimKeys(_response);
        });
    }

    protected processClaimKeys(response: Response): Promise<Anonymous32> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous32;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous32>(null as any);
    }

    /**
     * Upload cross-signing keys.
     * @param keys The keys to be published.
     * @return The provided keys were successfully uploaded.
     */
    uploadCrossSigningKeys(keys: Keys): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/keys/device_signing/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(keys);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadCrossSigningKeys(_response);
        });
    }

    protected processUploadCrossSigningKeys(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("The input was invalid in some way. This can include one of the\nfollowing error codes:\n\n* `M_INVALID_SIGNATURE`: For example, the self-signing or\n  user-signing key had an incorrect signature.\n* `M_MISSING_PARAM`: No master key is available.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return throwException("The public key of one of the keys is the same as one of the user\\\'s\ndevice IDs, or the request is not authorized for any other reason.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Download device identity keys.
     * @param query Query defining the keys to be downloaded
     * @return The device information
     */
    queryKeys(query: Query2): Promise<Anonymous33> {
        let url_ = this.baseUrl + "/_matrix/client/v3/keys/query";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQueryKeys(_response);
        });
    }

    protected processQueryKeys(response: Response): Promise<Anonymous33> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous33;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous33>(null as any);
    }

    /**
     * Upload cross-signing signatures.
     * @param signatures The signatures to be published.
     * @return The provided signatures were processed.
     */
    uploadCrossSigningSignatures(signatures: { [key: string]: { [key: string]: any; }; }): Promise<Anonymous34> {
        let url_ = this.baseUrl + "/_matrix/client/v3/keys/signatures/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(signatures);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadCrossSigningSignatures(_response);
        });
    }

    protected processUploadCrossSigningSignatures(response: Response): Promise<Anonymous34> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous34;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous34>(null as any);
    }

    /**
     * Upload end-to-end encryption keys.
     * @param keys The keys to be published
     * @return The provided keys were successfully uploaded.
     */
    uploadKeys(keys: Keys2): Promise<Anonymous35> {
        let url_ = this.baseUrl + "/_matrix/client/v3/keys/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(keys);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadKeys(_response);
        });
    }

    protected processUploadKeys(response: Response): Promise<Anonymous35> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous35;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous35>(null as any);
    }

    /**
     * Knock on a room, requesting permission to join.
     * @param roomIdOrAlias The room identifier or alias to knock upon.
     * @param server_name (optional) The servers to attempt to knock on the room through. One of the servers
    must be participating in the room.
     * @return The room has been knocked upon.

    The knocked room ID must be returned in the `room_id` field.
     */
    knockRoom(roomIdOrAlias: string, body: Body20, server_name?: string[] | null | undefined): Promise<Anonymous36> {
        let url_ = this.baseUrl + "/_matrix/client/v3/knock/{roomIdOrAlias}?";
        if (roomIdOrAlias === undefined || roomIdOrAlias === null)
            throw new Error("The parameter 'roomIdOrAlias' must be defined.");
        url_ = url_.replace("{roomIdOrAlias}", encodeURIComponent("" + roomIdOrAlias));
        if (server_name !== undefined && server_name !== null)
            server_name && server_name.forEach(item => { url_ += "server_name=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processKnockRoom(_response);
        });
    }

    protected processKnockRoom(response: Response): Promise<Anonymous36> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous36;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error28;
            return throwException("You do not have permission to knock on the room. A meaningful `errcode`\nand description error text will be returned. Example reasons for rejection are:\n\n- The room is not set up for knocking.\n- The user has been banned from the room.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error29;
            return throwException("The room could not be found or resolved to a room ID.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError11;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous36>(null as any);
    }

    /**
     * Get the supported login types to authenticate users
     * @return The login types the homeserver supports
     */
    getLoginFlows(): Promise<Anonymous37> {
        let url_ = this.baseUrl + "/_matrix/client/v3/login";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLoginFlows(_response);
        });
    }

    protected processGetLoginFlows(response: Response): Promise<Anonymous37> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous37;
            return result200;
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError12;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous37>(null as any);
    }

    /**
     * Authenticates the user.
     * @return The user has been authenticated.
     */
    login(body: Body21): Promise<Anonymous38> {
        let url_ = this.baseUrl + "/_matrix/client/v3/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<Anonymous38> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous38;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error30;
            return throwException("Part of the request was invalid. For example, the login type may not be recognised.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error31;
            return throwException("The login attempt failed. This can include one of the following error codes:\n  * `M_FORBIDDEN`: The provided authentication data was incorrect\n    or the requested device ID is the same as a cross-signing key\n    ID.\n  * `M_USER_DEACTIVATED`: The user has been deactivated.", status, _responseText, _headers, result403);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError13;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous38>(null as any);
    }

    /**
     * Redirect the user's browser to the SSO interface.
     * @param redirectUrl URI to which the user will be redirected after the homeserver has
    authenticated the user with SSO.
     */
    redirectToSSO(redirectUrl: string): Promise<void> {
        let url_ = this.baseUrl + "/_matrix/client/v3/login/sso/redirect?";
        if (redirectUrl === undefined || redirectUrl === null)
            throw new Error("The parameter 'redirectUrl' must be defined and cannot be null.");
        else
            url_ += "redirectUrl=" + encodeURIComponent("" + redirectUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRedirectToSSO(_response);
        });
    }

    protected processRedirectToSSO(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 302) {
            return response.text().then((_responseText) => {
            return throwException("A redirect to the SSO interface.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Redirect the user's browser to the SSO interface for an IdP.
     * @param idpId The `id` of the IdP from the `m.login.sso` `identity_providers`
    array denoting the user's selection.
     * @param redirectUrl URI to which the user will be redirected after the homeserver has
    authenticated the user with SSO.
     */
    redirectToIdP(idpId: string, redirectUrl: string): Promise<void> {
        let url_ = this.baseUrl + "/_matrix/client/v3/login/sso/redirect/{idpId}?";
        if (idpId === undefined || idpId === null)
            throw new Error("The parameter 'idpId' must be defined.");
        url_ = url_.replace("{idpId}", encodeURIComponent("" + idpId));
        if (redirectUrl === undefined || redirectUrl === null)
            throw new Error("The parameter 'redirectUrl' must be defined and cannot be null.");
        else
            url_ += "redirectUrl=" + encodeURIComponent("" + redirectUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRedirectToIdP(_response);
        });
    }

    protected processRedirectToIdP(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 302) {
            return response.text().then((_responseText) => {
            return throwException("A redirect to the SSO interface.", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("The IdP ID was not recognized by the server. The server is encouraged\nto provide a user-friendly page explaining the error given the user\nwill be navigated to it.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Invalidates a user access token
     * @return The access token used in the request was successfully invalidated.
     */
    logout(): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Invalidates all access tokens for a user
     * @return The user's access tokens were successfully invalidated.
     */
    logout_all(): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/logout/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout_all(_response);
        });
    }

    protected processLogout_all(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Gets a list of events that the user has been notified about
     * @param from (optional) Pagination token to continue from. This should be the `next_token`
    returned from an earlier call to this endpoint.
     * @param limit (optional) Limit on the number of events to return in this request.
     * @param only (optional) Allows basic filtering of events returned. Supply `highlight`
    to return only events where the notification had the highlight
    tweak set.
     * @return A batch of events is being returned
     */
    getNotifications(from?: string | null | undefined, limit?: number | null | undefined, only?: string | null | undefined): Promise<Anonymous39> {
        let url_ = this.baseUrl + "/_matrix/client/v3/notifications?";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (only !== undefined && only !== null)
            url_ += "only=" + encodeURIComponent("" + only) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetNotifications(_response);
        });
    }

    protected processGetNotifications(response: Response): Promise<Anonymous39> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous39;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous39>(null as any);
    }

    /**
     * Get this user's presence state.
     * @param userId The user whose presence state to get.
     * @return The presence state for this user.
     */
    getPresence(userId: string): Promise<Anonymous40> {
        let url_ = this.baseUrl + "/_matrix/client/v3/presence/{userId}/status";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPresence(_response);
        });
    }

    protected processGetPresence(response: Response): Promise<Anonymous40> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous40;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error32;
            return throwException("You are not allowed to see this user\'s presence status.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error33;
            return throwException("There is no presence state for this user. This user may not exist or\nisn\'t exposing presence information to you.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous40>(null as any);
    }

    /**
     * Update this user's presence state.
     * @param userId The user whose presence state to update.
     * @param presenceState The updated presence state.
     * @return The new presence state was set.
     */
    setPresence(userId: string, presenceState: PresenceState): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/presence/{userId}/status";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(presenceState);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetPresence(_response);
        });
    }

    protected processSetPresence(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError14;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Get this user's profile information.
     * @param userId The user whose profile information to get.
     * @return The profile information for this user.
     */
    getUserProfile(userId: string): Promise<Anonymous41> {
        let url_ = this.baseUrl + "/_matrix/client/v3/profile/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserProfile(_response);
        });
    }

    protected processGetUserProfile(response: Response): Promise<Anonymous41> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous41;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error34;
            return throwException("The server is unwilling to disclose whether the user exists and/or has profile information.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error35;
            return throwException("There is no profile information for this user or this user does not exist.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous41>(null as any);
    }

    /**
     * Get the user's avatar URL.
     * @param userId The user whose avatar URL to get.
     * @return The avatar URL for this user.
     */
    getAvatarUrl(userId: string): Promise<Anonymous42> {
        let url_ = this.baseUrl + "/_matrix/client/v3/profile/{userId}/avatar_url";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAvatarUrl(_response);
        });
    }

    protected processGetAvatarUrl(response: Response): Promise<Anonymous42> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous42;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("There is no avatar URL for this user or this user does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous42>(null as any);
    }

    /**
     * Set the user's avatar URL.
     * @param userId The user whose avatar URL to set.
     * @param avatar_url The new avatar information.
     * @return The avatar URL was set.
     */
    setAvatarUrl(userId: string, avatar_url: Avatar_url): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/profile/{userId}/avatar_url";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(avatar_url);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetAvatarUrl(_response);
        });
    }

    protected processSetAvatarUrl(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError15;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Get the user's display name.
     * @param userId The user whose display name to get.
     * @return The display name for this user.
     */
    getDisplayName(userId: string): Promise<Anonymous43> {
        let url_ = this.baseUrl + "/_matrix/client/v3/profile/{userId}/displayname";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDisplayName(_response);
        });
    }

    protected processGetDisplayName(response: Response): Promise<Anonymous43> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous43;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("There is no display name for this user or this user does not exist.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous43>(null as any);
    }

    /**
     * Set the user's display name.
     * @param userId The user whose display name to set.
     * @param displayName The new display name information.
     * @return The display name was set.
     */
    setDisplayName(userId: string, displayName: DisplayName): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/profile/{userId}/displayname";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(displayName);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetDisplayName(_response);
        });
    }

    protected processSetDisplayName(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError16;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Lists the public rooms on the server.
     * @param limit (optional) Limit the number of results returned.
     * @param since (optional) A pagination token from a previous request, allowing clients to
    get the next (or previous) batch of rooms.
    The direction of pagination is specified solely by which token
    is supplied, rather than via an explicit flag.
     * @param server (optional) The server to fetch the public room lists from. Defaults to the
    local server.
     * @return A list of the rooms on the server.
     */
    getPublicRooms(limit?: number | null | undefined, since?: string | null | undefined, server?: string | null | undefined): Promise<Anonymous44> {
        let url_ = this.baseUrl + "/_matrix/client/v3/publicRooms?";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (since !== undefined && since !== null)
            url_ += "since=" + encodeURIComponent("" + since) + "&";
        if (server !== undefined && server !== null)
            url_ += "server=" + encodeURIComponent("" + server) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPublicRooms(_response);
        });
    }

    protected processGetPublicRooms(response: Response): Promise<Anonymous44> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous44;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous44>(null as any);
    }

    /**
     * Lists the public rooms on the server with optional filter.
     * @param body Options for which rooms to return.
     * @param server (optional) The server to fetch the public room lists from. Defaults to the
    local server.
     * @return A list of the rooms on the server.
     */
    queryPublicRooms(body: Body22, server?: string | null | undefined): Promise<Anonymous45> {
        let url_ = this.baseUrl + "/_matrix/client/v3/publicRooms?";
        if (server !== undefined && server !== null)
            url_ += "server=" + encodeURIComponent("" + server) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQueryPublicRooms(_response);
        });
    }

    protected processQueryPublicRooms(response: Response): Promise<Anonymous45> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous45;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous45>(null as any);
    }

    /**
     * Gets the current pushers for the authenticated user
     * @return The pushers for this user.
     */
    getPushers(): Promise<Anonymous46> {
        let url_ = this.baseUrl + "/_matrix/client/v3/pushers";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPushers(_response);
        });
    }

    protected processGetPushers(response: Response): Promise<Anonymous46> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous46;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous46>(null as any);
    }

    /**
     * Modify a pusher for this user on the homeserver.
     * @param pusher The pusher information.
     * @return The pusher was set.
     */
    postPusher(pusher: Pusher): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/pushers/set";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pusher);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostPusher(_response);
        });
    }

    protected processPostPusher(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error36;
            return throwException("One or more of the pusher values were invalid.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError17;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Retrieve all push rulesets.
     * @return All the push rulesets for this user.
     */
    getPushRules(): Promise<Anonymous47> {
        let url_ = this.baseUrl + "/_matrix/client/v3/pushrules/";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPushRules(_response);
        });
    }

    protected processGetPushRules(response: Response): Promise<Anonymous47> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous47;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous47>(null as any);
    }

    /**
     * Delete a push rule.
     * @param scope `global` to specify global rules.
     * @param kind The kind of rule
     * @param ruleId The identifier for the rule.
     * @return The push rule was deleted.
     */
    deletePushRule(scope: string, kind: Kind, ruleId: string): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/pushrules/{scope}/{kind}/{ruleId}";
        if (scope === undefined || scope === null)
            throw new Error("The parameter 'scope' must be defined.");
        url_ = url_.replace("{scope}", encodeURIComponent("" + scope));
        if (kind === undefined || kind === null)
            throw new Error("The parameter 'kind' must be defined.");
        url_ = url_.replace("{kind}", encodeURIComponent("" + kind));
        if (ruleId === undefined || ruleId === null)
            throw new Error("The parameter 'ruleId' must be defined.");
        url_ = url_.replace("{ruleId}", encodeURIComponent("" + ruleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeletePushRule(_response);
        });
    }

    protected processDeletePushRule(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error37;
            return throwException("The push rule does not exist.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Retrieve a push rule.
     * @param scope `global` to specify global rules.
     * @param kind The kind of rule
     * @param ruleId The identifier for the rule.
     * @return The specific push rule. This will also include keys specific to the
    rule itself such as the rule's `actions` and `conditions` if set.
     */
    getPushRule(scope: string, kind: Kind2, ruleId: string): Promise<Anonymous48> {
        let url_ = this.baseUrl + "/_matrix/client/v3/pushrules/{scope}/{kind}/{ruleId}";
        if (scope === undefined || scope === null)
            throw new Error("The parameter 'scope' must be defined.");
        url_ = url_.replace("{scope}", encodeURIComponent("" + scope));
        if (kind === undefined || kind === null)
            throw new Error("The parameter 'kind' must be defined.");
        url_ = url_.replace("{kind}", encodeURIComponent("" + kind));
        if (ruleId === undefined || ruleId === null)
            throw new Error("The parameter 'ruleId' must be defined.");
        url_ = url_.replace("{ruleId}", encodeURIComponent("" + ruleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPushRule(_response);
        });
    }

    protected processGetPushRule(response: Response): Promise<Anonymous48> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous48;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error38;
            return throwException("The push rule does not exist.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous48>(null as any);
    }

    /**
     * Add or change a push rule.
     * @param scope `global` to specify global rules.
     * @param kind The kind of rule
     * @param ruleId The identifier for the rule. If the string starts with a dot ("."),
    the request MUST be rejected as this is reserved for server-default
    rules. Slashes ("/") and backslashes ("\\") are also not allowed.
     * @param pushrule The push rule data. Additional top-level keys may be present depending
    on the parameters for the rule `kind`.
     * @param before (optional) Use 'before' with a `rule_id` as its value to make the new rule the
    next-most important rule with respect to the given user defined rule.
    It is not possible to add a rule relative to a predefined server rule.
     * @param after (optional) This makes the new rule the next-less important rule relative to the
    given user defined rule. It is not possible to add a rule relative
    to a predefined server rule.
     * @return The push rule was created/updated.
     */
    setPushRule(scope: string, kind: Kind3, ruleId: string, pushrule: Pushrule, before?: string | null | undefined, after?: string | null | undefined): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/pushrules/{scope}/{kind}/{ruleId}?";
        if (scope === undefined || scope === null)
            throw new Error("The parameter 'scope' must be defined.");
        url_ = url_.replace("{scope}", encodeURIComponent("" + scope));
        if (kind === undefined || kind === null)
            throw new Error("The parameter 'kind' must be defined.");
        url_ = url_.replace("{kind}", encodeURIComponent("" + kind));
        if (ruleId === undefined || ruleId === null)
            throw new Error("The parameter 'ruleId' must be defined.");
        url_ = url_.replace("{ruleId}", encodeURIComponent("" + ruleId));
        if (before !== undefined && before !== null)
            url_ += "before=" + encodeURIComponent("" + before) + "&";
        if (after !== undefined && after !== null)
            url_ += "after=" + encodeURIComponent("" + after) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pushrule);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetPushRule(_response);
        });
    }

    protected processSetPushRule(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error39;
            return throwException("There was a problem configuring this push rule.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error40;
            return throwException("The push rule does not exist (when updating a push rule).", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError18;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * The actions for a push rule
     * @param scope Either `global` or `device/<profile_tag>` to specify global
    rules or device rules for the given `profile_tag`.
     * @param kind The kind of rule
     * @param ruleId The identifier for the rule.
     * @return The actions for this push rule.
     */
    getPushRuleActions(scope: string, kind: Kind4, ruleId: string): Promise<Anonymous49> {
        let url_ = this.baseUrl + "/_matrix/client/v3/pushrules/{scope}/{kind}/{ruleId}/actions";
        if (scope === undefined || scope === null)
            throw new Error("The parameter 'scope' must be defined.");
        url_ = url_.replace("{scope}", encodeURIComponent("" + scope));
        if (kind === undefined || kind === null)
            throw new Error("The parameter 'kind' must be defined.");
        url_ = url_.replace("{kind}", encodeURIComponent("" + kind));
        if (ruleId === undefined || ruleId === null)
            throw new Error("The parameter 'ruleId' must be defined.");
        url_ = url_.replace("{ruleId}", encodeURIComponent("" + ruleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetPushRuleActions(_response);
        });
    }

    protected processGetPushRuleActions(response: Response): Promise<Anonymous49> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous49;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error41;
            return throwException("The push rule does not exist.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous49>(null as any);
    }

    /**
     * Set the actions for a push rule.
     * @param scope `global` to specify global rules.
     * @param kind The kind of rule
     * @param ruleId The identifier for the rule.
     * @param body The action(s) to perform when the conditions for this rule are met.
     * @return The actions for the push rule were set.
     */
    setPushRuleActions(scope: string, kind: Kind5, ruleId: string, body: Body23): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/pushrules/{scope}/{kind}/{ruleId}/actions";
        if (scope === undefined || scope === null)
            throw new Error("The parameter 'scope' must be defined.");
        url_ = url_.replace("{scope}", encodeURIComponent("" + scope));
        if (kind === undefined || kind === null)
            throw new Error("The parameter 'kind' must be defined.");
        url_ = url_.replace("{kind}", encodeURIComponent("" + kind));
        if (ruleId === undefined || ruleId === null)
            throw new Error("The parameter 'ruleId' must be defined.");
        url_ = url_.replace("{ruleId}", encodeURIComponent("" + ruleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetPushRuleActions(_response);
        });
    }

    protected processSetPushRuleActions(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error42;
            return throwException("The push rule does not exist.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Get whether a push rule is enabled
     * @param scope Either `global` or `device/<profile_tag>` to specify global
    rules or device rules for the given `profile_tag`.
     * @param kind The kind of rule
     * @param ruleId The identifier for the rule.
     * @return Whether the push rule is enabled.
     */
    isPushRuleEnabled(scope: string, kind: Kind6, ruleId: string): Promise<Anonymous50> {
        let url_ = this.baseUrl + "/_matrix/client/v3/pushrules/{scope}/{kind}/{ruleId}/enabled";
        if (scope === undefined || scope === null)
            throw new Error("The parameter 'scope' must be defined.");
        url_ = url_.replace("{scope}", encodeURIComponent("" + scope));
        if (kind === undefined || kind === null)
            throw new Error("The parameter 'kind' must be defined.");
        url_ = url_.replace("{kind}", encodeURIComponent("" + kind));
        if (ruleId === undefined || ruleId === null)
            throw new Error("The parameter 'ruleId' must be defined.");
        url_ = url_.replace("{ruleId}", encodeURIComponent("" + ruleId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processIsPushRuleEnabled(_response);
        });
    }

    protected processIsPushRuleEnabled(response: Response): Promise<Anonymous50> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous50;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error43;
            return throwException("The push rule does not exist.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous50>(null as any);
    }

    /**
     * Enable or disable a push rule.
     * @param scope `global` to specify global rules.
     * @param kind The kind of rule
     * @param ruleId The identifier for the rule.
     * @param body Whether the push rule is enabled or not.
     * @return The push rule was enabled or disabled.
     */
    setPushRuleEnabled(scope: string, kind: Kind7, ruleId: string, body: Body24): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/pushrules/{scope}/{kind}/{ruleId}/enabled";
        if (scope === undefined || scope === null)
            throw new Error("The parameter 'scope' must be defined.");
        url_ = url_.replace("{scope}", encodeURIComponent("" + scope));
        if (kind === undefined || kind === null)
            throw new Error("The parameter 'kind' must be defined.");
        url_ = url_.replace("{kind}", encodeURIComponent("" + kind));
        if (ruleId === undefined || ruleId === null)
            throw new Error("The parameter 'ruleId' must be defined.");
        url_ = url_.replace("{ruleId}", encodeURIComponent("" + ruleId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetPushRuleEnabled(_response);
        });
    }

    protected processSetPushRuleEnabled(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error44;
            return throwException("The push rule does not exist.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Refresh an access token
     * @return A new access token and refresh token were generated.
     */
    refresh(body: Body25): Promise<Anonymous51> {
        let url_ = this.baseUrl + "/_matrix/client/v3/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRefresh(_response);
        });
    }

    protected processRefresh(response: Response): Promise<Anonymous51> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous51;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error45;
            return throwException("The provided token was unknown, or has already been used.", status, _responseText, _headers, result401);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError19;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous51>(null as any);
    }

    /**
     * Register for an account on this homeserver.
     * @param kind (optional) The kind of account to register. Defaults to `user`.
     * @return The account has been registered.
     */
    register(body: Body26, kind?: Kind8 | null | undefined): Promise<Anonymous52> {
        let url_ = this.baseUrl + "/_matrix/client/v3/register?";
        if (kind !== undefined && kind !== null)
            url_ += "kind=" + encodeURIComponent("" + kind) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<Anonymous52> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous52;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error46;
            return throwException("Part of the request was invalid. This may include one of the following error codes:\n\n* `M_USER_IN_USE` : The desired user ID is already taken.\n* `M_INVALID_USERNAME` : The desired user ID is not a valid user name.\n* `M_EXCLUSIVE` : The desired user ID is in the exclusive namespace\n  claimed by an application service.\n\nThese errors may be returned at any stage of the registration process,\nincluding after authentication if the requested user ID was registered\nwhilst the client was performing authentication.\n\nHomeservers MUST perform the relevant checks and return these codes before\nperforming User-Interactive Authentication, although they may also return\nthem after authentication is completed if, for example, the requested user ID\nwas registered whilst the client was performing authentication.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous53;
            return throwException("The homeserver requires additional authentication information.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error47;
            return throwException("The homeserver does not permit registering the account. This response\ncan be used to identify that a particular `kind` of account is not\nallowed, or that registration is generally not supported by the homeserver.", status, _responseText, _headers, result403);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError20;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous52>(null as any);
    }

    /**
     * Checks to see if a username is available on the server.
     * @param username The username to check the availability of.
     * @return The username is available
     */
    checkUsernameAvailability(username: string): Promise<Anonymous54> {
        let url_ = this.baseUrl + "/_matrix/client/v3/register/available?";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined and cannot be null.");
        else
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCheckUsernameAvailability(_response);
        });
    }

    protected processCheckUsernameAvailability(response: Response): Promise<Anonymous54> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous54;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error48;
            return throwException("Part of the request was invalid or the username is not available. This may\ninclude one of the following error codes:\n\n* `M_USER_IN_USE` : The desired username is already taken.\n* `M_INVALID_USERNAME` : The desired username is not a valid user name.\n* `M_EXCLUSIVE` : The desired username is in the exclusive namespace\n  claimed by an application service.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError21;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous54>(null as any);
    }

    /**
     * Begins the validation process for an email to be used during registration.
     * @return An email has been sent to the specified address. Note that this
    may be an email containing the validation token or it may be
    informing the user of an error.
     */
    requestTokenToRegisterEmail(body: Body27): Promise<RequestTokenResponse5> {
        let url_ = this.baseUrl + "/_matrix/client/v3/register/email/requestToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestTokenToRegisterEmail(_response);
        });
    }

    protected processRequestTokenToRegisterEmail(response: Response): Promise<RequestTokenResponse5> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RequestTokenResponse5;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error49;
            return throwException("Part of the request was invalid. This may include one of the following error codes:\n\n* `M_THREEPID_IN_USE` : The email address is already registered to an account on this server.\n  However, if the homeserver has the ability to send email, it is recommended that the server\n  instead send an email to the user with instructions on how to reset their password.\n  This prevents malicious parties from being able to determine if a given email address\n  has an account on the homeserver in question.\n* `M_SERVER_NOT_TRUSTED` : The `id_server` parameter refers to an identity server\n  that is not trusted by this homeserver.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error50;
            return throwException("The homeserver does not permit the address to be bound.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RequestTokenResponse5>(null as any);
    }

    /**
     * Requests a validation token be sent to the given phone number for the purpose of registering an account
     * @return An SMS message has been sent to the specified phone number. Note
    that this may be an SMS message containing the validation token or
    it may be informing the user of an error.
     */
    requestTokenToRegisterMSISDN(body: Body28): Promise<RequestTokenResponse6> {
        let url_ = this.baseUrl + "/_matrix/client/v3/register/msisdn/requestToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestTokenToRegisterMSISDN(_response);
        });
    }

    protected processRequestTokenToRegisterMSISDN(response: Response): Promise<RequestTokenResponse6> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RequestTokenResponse6;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error51;
            return throwException("Part of the request was invalid. This may include one of the following error codes:\n\n* `M_THREEPID_IN_USE` : The phone number is already registered to an account on this server.\n  However, if the homeserver has the ability to send SMS message, it is recommended that the server\n  instead send an SMS message to the user with instructions on how to reset their password.\n  This prevents malicious parties from being able to determine if a given phone number\n  has an account on the homeserver in question.\n* `M_SERVER_NOT_TRUSTED` : The `id_server` parameter refers to an identity server\n  that is not trusted by this homeserver.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error52;
            return throwException("The homeserver does not permit the address to be bound.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RequestTokenResponse6>(null as any);
    }

    /**
     * Delete the keys from the backup.
     * @param version The backup from which to delete the key
     * @return The update succeeded
     */
    deleteRoomKeys(version: string): Promise<RoomKeysUpdateResponse> {
        let url_ = this.baseUrl + "/_matrix/client/v3/room_keys/keys?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined and cannot be null.");
        else
            url_ += "version=" + encodeURIComponent("" + version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRoomKeys(_response);
        });
    }

    protected processDeleteRoomKeys(response: Response): Promise<RoomKeysUpdateResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RoomKeysUpdateResponse;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error53;
            return throwException("The backup was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError22;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoomKeysUpdateResponse>(null as any);
    }

    /**
     * Retrieve the keys from the backup.
     * @param version The backup from which to retrieve the keys.
     * @return The key data.  If no keys are found, then an object with an empty
    `rooms` property will be returned (`{"rooms": {}}`).
     */
    getRoomKeys(version: string): Promise<Anonymous55> {
        let url_ = this.baseUrl + "/_matrix/client/v3/room_keys/keys?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined and cannot be null.");
        else
            url_ += "version=" + encodeURIComponent("" + version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRoomKeys(_response);
        });
    }

    protected processGetRoomKeys(response: Response): Promise<Anonymous55> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous55;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error54;
            return throwException("The backup was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError23;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous55>(null as any);
    }

    /**
     * Store several keys in the backup.
     * @param version The backup in which to store the keys. Must be the current backup.
     * @param backupData The backup data.
     * @return The update succeeded
     */
    putRoomKeys(version: string, backupData: BackupData): Promise<RoomKeysUpdateResponse2> {
        let url_ = this.baseUrl + "/_matrix/client/v3/room_keys/keys?";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined and cannot be null.");
        else
            url_ += "version=" + encodeURIComponent("" + version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(backupData);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutRoomKeys(_response);
        });
    }

    protected processPutRoomKeys(response: Response): Promise<RoomKeysUpdateResponse2> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RoomKeysUpdateResponse2;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error55;
            return throwException("The version specified does not match the current backup version.\nThe current version will be included in the `current_version`\nfield.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error56;
            return throwException("The backup was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError24;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoomKeysUpdateResponse2>(null as any);
    }

    /**
     * Delete the keys from the backup for a given room.
     * @param version The backup from which to delete the key.
     * @param roomId The ID of the room that the specified key is for.
     * @return The update succeeded
     */
    deleteRoomKeysByRoomId(version: string, roomId: string): Promise<RoomKeysUpdateResponse3> {
        let url_ = this.baseUrl + "/_matrix/client/v3/room_keys/keys/{roomId}?";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined and cannot be null.");
        else
            url_ += "version=" + encodeURIComponent("" + version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRoomKeysByRoomId(_response);
        });
    }

    protected processDeleteRoomKeysByRoomId(response: Response): Promise<RoomKeysUpdateResponse3> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RoomKeysUpdateResponse3;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error57;
            return throwException("The backup was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError25;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoomKeysUpdateResponse3>(null as any);
    }

    /**
     * Retrieve the keys from the backup for a given room.
     * @param version The backup from which to retrieve the key.
     * @param roomId The ID of the room that the requested key is for.
     * @return The key data.  If no keys are found, then an object with an empty
    `sessions` property will be returned (`{"sessions": {}}`).
     */
    getRoomKeysByRoomId(version: string, roomId: string): Promise<RoomKeyBackup2> {
        let url_ = this.baseUrl + "/_matrix/client/v3/room_keys/keys/{roomId}?";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined and cannot be null.");
        else
            url_ += "version=" + encodeURIComponent("" + version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRoomKeysByRoomId(_response);
        });
    }

    protected processGetRoomKeysByRoomId(response: Response): Promise<RoomKeyBackup2> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RoomKeyBackup2;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error58;
            return throwException("The backup was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError26;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoomKeyBackup2>(null as any);
    }

    /**
     * Store several keys in the backup for a given room.
     * @param version The backup in which to store the keys. Must be the current backup.
     * @param roomId The ID of the room that the keys are for.
     * @param backupData The backup data
     * @return The update succeeded
     */
    putRoomKeysByRoomId(version: string, roomId: string, backupData: RoomKeyBackup): Promise<RoomKeysUpdateResponse4> {
        let url_ = this.baseUrl + "/_matrix/client/v3/room_keys/keys/{roomId}?";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined and cannot be null.");
        else
            url_ += "version=" + encodeURIComponent("" + version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(backupData);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutRoomKeysByRoomId(_response);
        });
    }

    protected processPutRoomKeysByRoomId(response: Response): Promise<RoomKeysUpdateResponse4> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RoomKeysUpdateResponse4;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error59;
            return throwException("The version specified does not match the current backup version.\nThe current version will be included in the `current_version`\nfield.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error60;
            return throwException("The backup was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError27;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoomKeysUpdateResponse4>(null as any);
    }

    /**
     * Delete a key from the backup.
     * @param version The backup from which to delete the key
     * @param roomId The ID of the room that the specified key is for.
     * @param sessionId The ID of the megolm session whose key is to be deleted.
     * @return The update succeeded
     */
    deleteRoomKeyBySessionId(version: string, roomId: string, sessionId: string): Promise<RoomKeysUpdateResponse5> {
        let url_ = this.baseUrl + "/_matrix/client/v3/room_keys/keys/{roomId}/{sessionId}?";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        if (sessionId === undefined || sessionId === null)
            throw new Error("The parameter 'sessionId' must be defined.");
        url_ = url_.replace("{sessionId}", encodeURIComponent("" + sessionId));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined and cannot be null.");
        else
            url_ += "version=" + encodeURIComponent("" + version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRoomKeyBySessionId(_response);
        });
    }

    protected processDeleteRoomKeyBySessionId(response: Response): Promise<RoomKeysUpdateResponse5> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RoomKeysUpdateResponse5;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error61;
            return throwException("The backup was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError28;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoomKeysUpdateResponse5>(null as any);
    }

    /**
     * Retrieve a key from the backup.
     * @param version The backup from which to retrieve the key.
     * @param roomId The ID of the room that the requested key is for.
     * @param sessionId The ID of the megolm session whose key is requested.
     * @return The key data
     */
    getRoomKeyBySessionId(version: string, roomId: string, sessionId: string): Promise<KeyBackupData2> {
        let url_ = this.baseUrl + "/_matrix/client/v3/room_keys/keys/{roomId}/{sessionId}?";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        if (sessionId === undefined || sessionId === null)
            throw new Error("The parameter 'sessionId' must be defined.");
        url_ = url_.replace("{sessionId}", encodeURIComponent("" + sessionId));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined and cannot be null.");
        else
            url_ += "version=" + encodeURIComponent("" + version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRoomKeyBySessionId(_response);
        });
    }

    protected processGetRoomKeyBySessionId(response: Response): Promise<KeyBackupData2> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as KeyBackupData2;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error62;
            return throwException("The key or backup was not found.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError29;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KeyBackupData2>(null as any);
    }

    /**
     * Store a key in the backup.
     * @param version The backup in which to store the key. Must be the current backup.
     * @param roomId The ID of the room that the key is for.
     * @param sessionId The ID of the megolm session that the key is for.
     * @param data The key data.
     * @return The update succeeded.
     */
    putRoomKeyBySessionId(version: string, roomId: string, sessionId: string, data: KeyBackupData): Promise<RoomKeysUpdateResponse6> {
        let url_ = this.baseUrl + "/_matrix/client/v3/room_keys/keys/{roomId}/{sessionId}?";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        if (sessionId === undefined || sessionId === null)
            throw new Error("The parameter 'sessionId' must be defined.");
        url_ = url_.replace("{sessionId}", encodeURIComponent("" + sessionId));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined and cannot be null.");
        else
            url_ += "version=" + encodeURIComponent("" + version) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutRoomKeyBySessionId(_response);
        });
    }

    protected processPutRoomKeyBySessionId(response: Response): Promise<RoomKeysUpdateResponse6> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RoomKeysUpdateResponse6;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error63;
            return throwException("The version specified does not match the current backup version.\nThe current version will be included in the `current_version`\nfield.", status, _responseText, _headers, result403);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError30;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoomKeysUpdateResponse6>(null as any);
    }

    /**
     * Get information about the latest backup version.
     * @return The information about the backup.
     */
    getRoomKeysVersionCurrent(): Promise<Anonymous56> {
        let url_ = this.baseUrl + "/_matrix/client/v3/room_keys/version";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRoomKeysVersionCurrent(_response);
        });
    }

    protected processGetRoomKeysVersionCurrent(response: Response): Promise<Anonymous56> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous56;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error64;
            return throwException("No backup exists.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError31;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous56>(null as any);
    }

    /**
     * Create a new backup.
     * @param version The backup configuration.
     * @return The version id of the new backup.
     */
    postRoomKeysVersion(version: Version): Promise<Anonymous57> {
        let url_ = this.baseUrl + "/_matrix/client/v3/room_keys/version";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(version);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostRoomKeysVersion(_response);
        });
    }

    protected processPostRoomKeysVersion(response: Response): Promise<Anonymous57> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous57;
            return result200;
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError32;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous57>(null as any);
    }

    /**
     * Delete an existing key backup.
     * @param version The backup version to delete, as returned in the `version`
    parameter in the response of
    [`POST /_matrix/client/v3/room_keys/version`](https://spec.matrix.org/v1.5/client-server-api/#post_matrixclientv3room_keysversion)
    or [`GET /_matrix/client/v3/room_keys/version/{version}`](https://spec.matrix.org/v1.5/client-server-api/#get_matrixclientv3room_keysversionversion).
     * @return The delete succeeded, or the specified backup was previously
    deleted.
     */
    deleteRoomKeysVersion(version: string): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/room_keys/version/{version}";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRoomKeysVersion(_response);
        });
    }

    protected processDeleteRoomKeysVersion(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error65;
            return throwException("The backup specified does not exist. If the backup was previously\ndeleted, the call should succeed rather than returning an error.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError33;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Get information about an existing backup.
     * @param version The backup version to get, as returned in the `version` parameter
    of the response in
    [`POST /_matrix/client/v3/room_keys/version`](https://spec.matrix.org/v1.5/client-server-api/#post_matrixclientv3room_keysversion)
    or this endpoint.
     * @return The information about the requested backup.
     */
    getRoomKeysVersion(version: string): Promise<Anonymous58> {
        let url_ = this.baseUrl + "/_matrix/client/v3/room_keys/version/{version}";
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRoomKeysVersion(_response);
        });
    }

    protected processGetRoomKeysVersion(response: Response): Promise<Anonymous58> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous58;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error66;
            return throwException("The backup specified does not exist.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError34;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous58>(null as any);
    }

    /**
     * Update information about an existing backup.
     * @param versionPath The backup version to update, as returned in the `version`
    parameter in the response of
    [`POST /_matrix/client/v3/room_keys/version`](https://spec.matrix.org/v1.5/client-server-api/#post_matrixclientv3room_keysversion)
    or [`GET /_matrix/client/v3/room_keys/version/{version}`](https://spec.matrix.org/v1.5/client-server-api/#get_matrixclientv3room_keysversionversion).
     * @param versionBody The backup configuration
     * @return The update succeeded.
     */
    putRoomKeysVersion(versionPath: string, versionBody: Version2): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/room_keys/version/{version}";
        if (versionPath === undefined || versionPath === null)
            throw new Error("The parameter 'versionPath' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + versionPath));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(versionBody);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPutRoomKeysVersion(_response);
        });
    }

    protected processPutRoomKeysVersion(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error67;
            return throwException("A parameter was incorrect.  For example, the `algorithm` does not\nmatch the current backup algorithm, or the `version` in the body\ndoes not match the `version` in the path.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error68;
            return throwException("The backup specified does not exist.", status, _responseText, _headers, result404);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError35;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Get a list of local aliases on a given room.
     * @param roomId The room ID to find local aliases of.
     * @return The list of local aliases for the room.
     */
    getLocalAliases(roomId: string): Promise<Anonymous59> {
        let url_ = this.baseUrl + "/_matrix/client/v3/rooms/{roomId}/aliases";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetLocalAliases(_response);
        });
    }

    protected processGetLocalAliases(response: Response): Promise<Anonymous59> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous59;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error69;
            return throwException("The given `roomAlias` is not a valid room alias.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error70;
            return throwException("The user is not permitted to retrieve the list of local aliases for the room.", status, _responseText, _headers, result403);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError36;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous59>(null as any);
    }

    /**
     * Ban a user in the room.
     * @param roomId The room identifier (not alias) from which the user should be banned.
     * @return The user has been kicked and banned from the room.
     */
    ban(roomId: string, body: Body29): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/rooms/{roomId}/ban";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processBan(_response);
        });
    }

    protected processBan(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error71;
            return throwException("You do not have permission to ban the user from the room. A meaningful `errcode` and description error text will be returned. Example reasons for rejections are:\n\n- The banner is not currently in the room.\n- The banner\'s power level is insufficient to ban users from the room.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Get events and state around the specified event.
     * @param roomId The room to get events from.
     * @param eventId The event to get context around.
     * @param limit (optional) The maximum number of events to return. Default: 10.
     * @param filter (optional) A JSON `RoomEventFilter` to filter the returned events with. The
    filter is only applied to `events_before`, `events_after`, and
    `state`. It is not applied to the `event` itself. The filter may
    be applied before or/and after the `limit` parameter - whichever the
    homeserver prefers.

    See [Filtering](https://spec.matrix.org/v1.5/client-server-api/#filtering) for more information.
     * @return The events and state surrounding the requested event.
     */
    getEventContext(roomId: string, eventId: string, limit?: number | null | undefined, filter?: string | null | undefined): Promise<Anonymous60> {
        let url_ = this.baseUrl + "/_matrix/client/v3/rooms/{roomId}/context/{eventId}?";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetEventContext(_response);
        });
    }

    protected processGetEventContext(response: Response): Promise<Anonymous60> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous60;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous60>(null as any);
    }

    /**
     * Get a single event by event ID.
     * @param roomId The ID of the room the event is in.
     * @param eventId The event ID to get.
     * @return The full event.
     */
    getOneRoomEvent(roomId: string, eventId: string): Promise<ClientEvent2> {
        let url_ = this.baseUrl + "/_matrix/client/v3/rooms/{roomId}/event/{eventId}";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOneRoomEvent(_response);
        });
    }

    protected processGetOneRoomEvent(response: Response): Promise<ClientEvent2> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClientEvent2;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error72;
            return throwException("The event was not found or you do not have permission to read this event.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientEvent2>(null as any);
    }

    /**
     * Stop the requesting user remembering about a particular room.
     * @param roomId The room identifier to forget.
     * @return The room has been forgotten.
     */
    forgetRoom(roomId: string): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/rooms/{roomId}/forget";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForgetRoom(_response);
        });
    }

    protected processForgetRoom(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error73;
            return throwException("The user has not left the room", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError37;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Snapshot the current state of a room and its most recent messages.
     * @param roomId The room to get the data.
     * @return The current state of the room
     * @deprecated
     */
    roomInitialSync(roomId: string): Promise<RoomInfo> {
        let url_ = this.baseUrl + "/_matrix/client/v3/rooms/{roomId}/initialSync";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRoomInitialSync(_response);
        });
    }

    protected processRoomInitialSync(response: Response): Promise<RoomInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RoomInfo;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("You aren\'t a member of the room and weren\'t previously a member of the room.\n", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoomInfo>(null as any);
    }

    /**
     * Invite a user to participate in a particular room.
     * @param roomId The room identifier (not alias) to which to invite the user.
     * @return The user has been invited to join the room.
     */
    inviteBy3PID(roomId: string, body: Body30): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/rooms/{roomId}/invite";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInviteBy3PID(_response);
        });
    }

    protected processInviteBy3PID(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error74;
            return throwException("You do not have permission to invite the user to the room. A meaningful `errcode` and description error text will be returned. Example reasons for rejections are:\n\n- The invitee has been banned from the room.\n- The invitee is already a member of the room.\n- The inviter is not currently in the room.\n- The inviter\'s power level is insufficient to invite users to the room.", status, _responseText, _headers, result403);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError38;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Invite a user to participate in a particular room.
     * @param roomId The room identifier (not alias) to which to invite the user.
     * @return The user has been invited to join the room, or was already invited to the room.
     */
    inviteUser(roomId: string, body: Body31): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/rooms/{roomId}/invite ";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInviteUser(_response);
        });
    }

    protected processInviteUser(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error75;
            return throwException("\nThe request is invalid. A meaningful `errcode` and description\nerror text will be returned. Example reasons for rejection include:\n\n- The request body is malformed (`errcode` set to `M_BAD_JSON`\n  or `M_NOT_JSON`).\n\n- One or more users being invited to the room are residents of a\n  homeserver which does not support the requested room version. The\n  `errcode` will be `M_UNSUPPORTED_ROOM_VERSION` in these cases.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error76;
            return throwException("You do not have permission to invite the user to the room. A meaningful `errcode` and description error text will be returned. Example reasons for rejections are:\n\n- The invitee has been banned from the room.\n- The invitee is already a member of the room.\n- The inviter is not currently in the room.\n- The inviter\'s power level is insufficient to invite users to the room.", status, _responseText, _headers, result403);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError39;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Start the requesting user participating in a particular room.
     * @param roomId The room identifier (not alias) to join.
     * @return The room has been joined.

    The joined room ID must be returned in the `room_id` field.
     */
    joinRoomById(roomId: string, body: Body32): Promise<Anonymous61> {
        let url_ = this.baseUrl + "/_matrix/client/v3/rooms/{roomId}/join";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processJoinRoomById(_response);
        });
    }

    protected processJoinRoomById(response: Response): Promise<Anonymous61> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous61;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error77;
            return throwException("You do not have permission to join the room. A meaningful `errcode`\nand description error text will be returned. Example reasons for rejection are:\n\n- The room is invite-only and the user was not invited.\n- The user has been banned from the room.\n- The room is restricted and the user failed to satisfy any of the conditions.", status, _responseText, _headers, result403);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError40;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous61>(null as any);
    }

    /**
     * Gets the list of currently joined users and their profile data.
     * @param roomId The room to get the members of.
     * @return A map of MXID to room member objects.
     */
    getJoinedMembersByRoom(roomId: string): Promise<Anonymous62> {
        let url_ = this.baseUrl + "/_matrix/client/v3/rooms/{roomId}/joined_members";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetJoinedMembersByRoom(_response);
        });
    }

    protected processGetJoinedMembersByRoom(response: Response): Promise<Anonymous62> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous62;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("You aren\'t a member of the room.\n", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous62>(null as any);
    }

    /**
     * Kick a user from the room.
     * @param roomId The room identifier (not alias) from which the user should be kicked.
     * @return The user has been kicked from the room.
     */
    kick(roomId: string, body: Body33): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/rooms/{roomId}/kick";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processKick(_response);
        });
    }

    protected processKick(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error78;
            return throwException("You do not have permission to kick the user from the room. A meaningful `errcode` and\ndescription error text will be returned. Example reasons for rejections are:\n\n- The kicker is not currently in the room.\n- The kickee is not currently in the room.\n- The kicker\'s power level is insufficient to kick users from the room.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Stop the requesting user participating in a particular room.
     * @param roomId The room identifier to leave.
     * @return The room has been left.
     */
    leaveRoom(roomId: string, body: Body34): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/rooms/{roomId}/leave";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLeaveRoom(_response);
        });
    }

    protected processLeaveRoom(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError41;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Get the m.room.member events for the room.
     * @param roomId The room to get the member events for.
     * @param at (optional) The point in time (pagination token) to return members for in the room.
    This token can be obtained from a `prev_batch` token returned for
    each room by the sync API. Defaults to the current state of the room,
    as determined by the server.
     * @param membership (optional) The kind of membership to filter for. Defaults to no filtering if
    unspecified. When specified alongside `not_membership`, the two
    parameters create an 'or' condition: either the membership *is*
    the same as `membership` **or** *is not* the same as `not_membership`.
     * @param not_membership (optional) The kind of membership to exclude from the results. Defaults to no
    filtering if unspecified.
     * @return A list of members of the room. If you are joined to the room then
    this will be the current members of the room. If you have left the
    room then this will be the members of the room when you left.
     */
    getMembersByRoom(roomId: string, at?: string | null | undefined, membership?: Membership | null | undefined, not_membership?: Not_membership | null | undefined): Promise<Anonymous63> {
        let url_ = this.baseUrl + "/_matrix/client/v3/rooms/{roomId}/members?";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        if (at !== undefined && at !== null)
            url_ += "at=" + encodeURIComponent("" + at) + "&";
        if (membership !== undefined && membership !== null)
            url_ += "membership=" + encodeURIComponent("" + membership) + "&";
        if (not_membership !== undefined && not_membership !== null)
            url_ += "not_membership=" + encodeURIComponent("" + not_membership) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMembersByRoom(_response);
        });
    }

    protected processGetMembersByRoom(response: Response): Promise<Anonymous63> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous63;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("You aren\'t a member of the room and weren\'t previously a member of the room.\n", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous63>(null as any);
    }

    /**
     * Get a list of events for this room
     * @param roomId The room to get events from.
     * @param dir The direction to return events from. If this is set to `f`, events
    will be returned in chronological order starting at `from`. If it
    is set to `b`, events will be returned in *reverse* chronological
    order, again starting at `from`.
     * @param from (optional) The token to start returning events from. This token can be obtained
    from a `prev_batch` or `next_batch` token returned by the `/sync` endpoint,
    or from an `end` token returned by a previous request to this endpoint.

    This endpoint can also accept a value returned as a `start` token
    by a previous request to this endpoint, though servers are not
    required to support this. Clients should not rely on the behaviour.

    If it is not provided, the homeserver shall return a list of messages
    from the first or last (per the value of the `dir` parameter) visible
    event in the room history for the requesting user.
     * @param to (optional) The token to stop returning events at. This token can be obtained from
    a `prev_batch` or `next_batch` token returned by the `/sync` endpoint,
    or from an `end` token returned by a previous request to this endpoint.
     * @param limit (optional) The maximum number of events to return. Default: 10.
     * @param filter (optional) A JSON RoomEventFilter to filter returned events with.
     * @return A list of messages with a new token to request more.
     */
    getRoomEvents(roomId: string, dir: Dir4, from?: string | null | undefined, to?: string | null | undefined, limit?: number | null | undefined, filter?: string | null | undefined): Promise<Anonymous64> {
        let url_ = this.baseUrl + "/_matrix/client/v3/rooms/{roomId}/messages?";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        if (dir === undefined || dir === null)
            throw new Error("The parameter 'dir' must be defined and cannot be null.");
        else
            url_ += "dir=" + encodeURIComponent("" + dir) + "&";
        if (from !== undefined && from !== null)
            url_ += "from=" + encodeURIComponent("" + from) + "&";
        if (to !== undefined && to !== null)
            url_ += "to=" + encodeURIComponent("" + to) + "&";
        if (limit !== undefined && limit !== null)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRoomEvents(_response);
        });
    }

    protected processGetRoomEvents(response: Response): Promise<Anonymous64> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous64;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("You aren\'t a member of the room.\n", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous64>(null as any);
    }

    /**
     * Set the position of the read marker for a room.
     * @param roomId The room ID to set the read marker in for the user.
     * @param body The read marker and optional read receipt locations.
     * @return The read marker, and read receipt(s) if provided, have been updated.
     */
    setReadMarker(roomId: string, body: Body35): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/rooms/{roomId}/read_markers";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetReadMarker(_response);
        });
    }

    protected processSetReadMarker(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError42;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Send a receipt for the given event ID.
     * @param roomId The room in which to send the event.
     * @param receiptType The type of receipt to send. This can also be `m.fully_read` as an
    alternative to [`/read_makers`](https://spec.matrix.org/v1.5/client-server-api/#post_matrixclientv3roomsroomidread_markers).

    Note that `m.fully_read` does not appear under `m.receipt`: this endpoint
    effectively calls `/read_markers` internally when presented with a receipt
    type of `m.fully_read`.
     * @param eventId The event ID to acknowledge up to.
     * @param receipt Extra receipt information to attach to `content` if any. The
    server will automatically set the `ts` field.
     * @return The receipt was sent.
     */
    postReceipt(roomId: string, receiptType: ReceiptType, eventId: string, receipt: Receipt): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/rooms/{roomId}/receipt/{receiptType}/{eventId}";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        if (receiptType === undefined || receiptType === null)
            throw new Error("The parameter 'receiptType' must be defined.");
        url_ = url_.replace("{receiptType}", encodeURIComponent("" + receiptType));
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(receipt);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostReceipt(_response);
        });
    }

    protected processPostReceipt(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error79;
            return throwException("The `thread_id` is invalid in some way. For example:\n* It is not a string.\n* It is empty.\n* It is provided for an incompatible receipt type.\n* The `event_id` is not related to the `thread_id`.", status, _responseText, _headers, result400);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError43;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Strips all non-integrity-critical information out of an event.
     * @param roomId The room from which to redact the event.
     * @param eventId The ID of the event to redact
     * @param txnId The [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers) for this event. Clients should generate a
    unique ID; it will be used by the server to ensure idempotency of requests.
     * @return An ID for the redaction event.
     */
    redactEvent(roomId: string, eventId: string, txnId: string, body: Body36): Promise<Anonymous65> {
        let url_ = this.baseUrl + "/_matrix/client/v3/rooms/{roomId}/redact/{eventId}/{txnId}";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        if (txnId === undefined || txnId === null)
            throw new Error("The parameter 'txnId' must be defined.");
        url_ = url_.replace("{txnId}", encodeURIComponent("" + txnId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRedactEvent(_response);
        });
    }

    protected processRedactEvent(response: Response): Promise<Anonymous65> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous65;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous65>(null as any);
    }

    /**
     * Reports an event as inappropriate.
     * @param roomId The room in which the event being reported is located.
     * @param eventId The event to report.
     * @return The event has been reported successfully.
     */
    reportContent(roomId: string, eventId: string, body: Body37): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/rooms/{roomId}/report/{eventId}";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        if (eventId === undefined || eventId === null)
            throw new Error("The parameter 'eventId' must be defined.");
        url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processReportContent(_response);
        });
    }

    protected processReportContent(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Send a message event to the given room.
     * @param roomId The room to send the event to.
     * @param eventType The type of event to send.
     * @param txnId The [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers) for this event. Clients should generate an
    ID unique across requests with the same access token; it will be
    used by the server to ensure idempotency of requests.
     * @return An ID for the sent event.
     */
    sendMessage(roomId: string, eventType: string, txnId: string, body: any): Promise<Anonymous66> {
        let url_ = this.baseUrl + "/_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        if (eventType === undefined || eventType === null)
            throw new Error("The parameter 'eventType' must be defined.");
        url_ = url_.replace("{eventType}", encodeURIComponent("" + eventType));
        if (txnId === undefined || txnId === null)
            throw new Error("The parameter 'txnId' must be defined.");
        url_ = url_.replace("{txnId}", encodeURIComponent("" + txnId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendMessage(_response);
        });
    }

    protected processSendMessage(response: Response): Promise<Anonymous66> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous66;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous66>(null as any);
    }

    /**
     * Get all state events in the current state of a room.
     * @param roomId The room to look up the state for.
     * @return The current state of the room
     */
    getRoomState(roomId: string): Promise<ClientEvent3[]> {
        let url_ = this.baseUrl + "/_matrix/client/v3/rooms/{roomId}/state";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRoomState(_response);
        });
    }

    protected processGetRoomState(response: Response): Promise<ClientEvent3[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ClientEvent3[];
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("You aren\'t a member of the room and weren\'t previously a member of the room.\n", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientEvent3[]>(null as any);
    }

    /**
     * Get the state identified by the type and key.
     * @param roomId The room to look up the state in.
     * @param eventType The type of state to look up.
     * @param stateKey The key of the state to look up. Defaults to an empty string. When
    an empty string, the trailing slash on this endpoint is optional.
     * @return The content of the state event.
     */
    getRoomStateWithKey(roomId: string, eventType: string, stateKey: string): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/rooms/{roomId}/state/{eventType}/{stateKey}";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        if (eventType === undefined || eventType === null)
            throw new Error("The parameter 'eventType' must be defined.");
        url_ = url_.replace("{eventType}", encodeURIComponent("" + eventType));
        if (stateKey === undefined || stateKey === null)
            throw new Error("The parameter 'stateKey' must be defined.");
        url_ = url_.replace("{stateKey}", encodeURIComponent("" + stateKey));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRoomStateWithKey(_response);
        });
    }

    protected processGetRoomStateWithKey(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            return throwException("You aren\'t a member of the room and weren\'t previously a member of the room.\n", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("The room has no state with the given type or key.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Send a state event to the given room.
     * @param roomId The room to set the state in
     * @param eventType The type of event to send.
     * @param stateKey The state_key for the state to send. Defaults to the empty string. When
    an empty string, the trailing slash on this endpoint is optional.
     * @return An ID for the sent event.
     */
    setRoomStateWithKey(roomId: string, eventType: string, stateKey: string, body: any): Promise<Anonymous67> {
        let url_ = this.baseUrl + "/_matrix/client/v3/rooms/{roomId}/state/{eventType}/{stateKey}";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        if (eventType === undefined || eventType === null)
            throw new Error("The parameter 'eventType' must be defined.");
        url_ = url_.replace("{eventType}", encodeURIComponent("" + eventType));
        if (stateKey === undefined || stateKey === null)
            throw new Error("The parameter 'stateKey' must be defined.");
        url_ = url_.replace("{stateKey}", encodeURIComponent("" + stateKey));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetRoomStateWithKey(_response);
        });
    }

    protected processSetRoomStateWithKey(response: Response): Promise<Anonymous67> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous67;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error80;
            return throwException("The sender\'s request is malformed.\n\nSome example error codes include:\n\n* `M_INVALID_PARAM`: One or more aliases within the `m.room.canonical_alias`\n  event have invalid syntax.\n\n* `M_BAD_ALIAS`: One or more aliases within the `m.room.canonical_alias` event\n  do not point to the room ID for which the state event is to be sent to.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error81;
            return throwException("The sender doesn\'t have permission to send the event into the room.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous67>(null as any);
    }

    /**
     * Informs the server that the user has started or stopped typing.
     * @param userId The user who has started to type.
     * @param roomId The room in which the user is typing.
     * @param typingState The current typing state.
     * @return The new typing state was set.
     */
    setTyping(userId: string, roomId: string, typingState: TypingState): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/rooms/{roomId}/typing/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(typingState);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetTyping(_response);
        });
    }

    protected processSetTyping(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError44;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Unban a user from the room.
     * @param roomId The room identifier (not alias) from which the user should be unbanned.
     * @return The user has been unbanned from the room.
     */
    unban(roomId: string, body: Body38): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/rooms/{roomId}/unban";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUnban(_response);
        });
    }

    protected processUnban(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error82;
            return throwException("You do not have permission to unban the user from the room. A meaningful `errcode` and description error text will be returned. Example reasons for rejections are:\n\n- The unbanner\'s power level is insufficient to unban users from the room.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Upgrades a room to a new room version.
     * @param roomId The ID of the room to upgrade.
     * @return The room was successfully upgraded.
     */
    upgradeRoom(roomId: string, body: Body39): Promise<Anonymous68> {
        let url_ = this.baseUrl + "/_matrix/client/v3/rooms/{roomId}/upgrade";
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpgradeRoom(_response);
        });
    }

    protected processUpgradeRoom(response: Response): Promise<Anonymous68> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous68;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error83;
            return throwException("The request was invalid. One way this can happen is if the room version\nrequested is not supported by the homeserver.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error84;
            return throwException("The user is not permitted to upgrade the room.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous68>(null as any);
    }

    /**
     * Perform a server-side search.
     * @param next_batch (optional) The point to return events from. If given, this should be a
    `next_batch` result from a previous call to this endpoint.
     * @return Results of the search.
     */
    search(body: Body40, next_batch?: string | null | undefined): Promise<Results> {
        let url_ = this.baseUrl + "/_matrix/client/v3/search?";
        if (next_batch !== undefined && next_batch !== null)
            url_ += "next_batch=" + encodeURIComponent("" + next_batch) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<Results> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Results;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Part of the request was invalid.", status, _responseText, _headers);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError45;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Results>(null as any);
    }

    /**
     * Send an event to a given set of devices.
     * @param eventType The type of event to send.
     * @param txnId The [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers) for this event. Clients should generate an
    ID unique across requests with the same access token; it will be
    used by the server to ensure idempotency of requests.
     * @return The message was successfully sent.
     */
    sendToDevice(eventType: string, txnId: string, body: Body41): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/sendToDevice/{eventType}/{txnId}";
        if (eventType === undefined || eventType === null)
            throw new Error("The parameter 'eventType' must be defined.");
        url_ = url_.replace("{eventType}", encodeURIComponent("" + eventType));
        if (txnId === undefined || txnId === null)
            throw new Error("The parameter 'txnId' must be defined.");
        url_ = url_.replace("{txnId}", encodeURIComponent("" + txnId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendToDevice(_response);
        });
    }

    protected processSendToDevice(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Synchronise the client's state and receive new messages.
     * @param filter (optional) The ID of a filter created using the filter API or a filter JSON
    object encoded as a string. The server will detect whether it is
    an ID or a JSON object by whether the first character is a `"{"`
    open brace. Passing the JSON inline is best suited to one off
    requests. Creating a filter using the filter API is recommended for
    clients that reuse the same filter multiple times, for example in
    long poll requests.

    See [Filtering](https://spec.matrix.org/v1.5/client-server-api/#filtering) for more information.
     * @param since (optional) A point in time to continue a sync from. This should be the
    `next_batch` token returned by an earlier call to this endpoint.
     * @param full_state (optional) Controls whether to include the full state for all rooms the user
    is a member of.

    If this is set to `true`, then all state events will be returned,
    even if `since` is non-empty. The timeline will still be limited
    by the `since` parameter. In this case, the `timeout` parameter
    will be ignored and the query will return immediately, possibly with
    an empty timeline.

    If `false`, and `since` is non-empty, only state which has
    changed since the point indicated by `since` will be returned.

    By default, this is `false`.
     * @param set_presence (optional) Controls whether the client is automatically marked as online by
    polling this API. If this parameter is omitted then the client is
    automatically marked as online when it uses this API. Otherwise if
    the parameter is set to "offline" then the client is not marked as
    being online when it uses this API. When set to "unavailable", the
    client is marked as being idle.
     * @param timeout (optional) The maximum time to wait, in milliseconds, before returning this
    request. If no events (or other data) become available before this
    time elapses, the server will return a response with empty fields.

    By default, this is `0`, so the server will return immediately
    even if the response is empty.
     * @return The initial snapshot or delta for the client to use to update their state.
     */
    sync(filter?: string | null | undefined, since?: string | null | undefined, full_state?: boolean | null | undefined, set_presence?: Set_presence | null | undefined, timeout?: number | null | undefined): Promise<Anonymous69> {
        let url_ = this.baseUrl + "/_matrix/client/v3/sync?";
        if (filter !== undefined && filter !== null)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&";
        if (since !== undefined && since !== null)
            url_ += "since=" + encodeURIComponent("" + since) + "&";
        if (full_state !== undefined && full_state !== null)
            url_ += "full_state=" + encodeURIComponent("" + full_state) + "&";
        if (set_presence !== undefined && set_presence !== null)
            url_ += "set_presence=" + encodeURIComponent("" + set_presence) + "&";
        if (timeout !== undefined && timeout !== null)
            url_ += "timeout=" + encodeURIComponent("" + timeout) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSync(_response);
        });
    }

    protected processSync(response: Response): Promise<Anonymous69> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous69;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous69>(null as any);
    }

    /**
     * Reverse-lookup third party locations given a Matrix room alias.
     * @param alias The Matrix room alias to look up.
     * @return All found third party locations.
     */
    queryLocationByAlias(alias: string): Promise<Location[]> {
        let url_ = this.baseUrl + "/_matrix/client/v3/thirdparty/location?";
        if (alias === undefined || alias === null)
            throw new Error("The parameter 'alias' must be defined and cannot be null.");
        else
            url_ += "alias=" + encodeURIComponent("" + alias) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQueryLocationByAlias(_response);
        });
    }

    protected processQueryLocationByAlias(response: Response): Promise<Location[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Location[];
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error85;
            return throwException("The Matrix room alias was not found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Location[]>(null as any);
    }

    /**
     * Retrieve Matrix-side portals rooms leading to a third party location.
     * @param protocol The protocol used to communicate to the third party network.
     * @param searchFields (optional) One or more custom fields to help identify the third party
    location.
     * @return At least one portal room was found.
     */
    queryLocationByProtocol(protocol: string, searchFields?: string | null | undefined): Promise<Location2[]> {
        let url_ = this.baseUrl + "/_matrix/client/v3/thirdparty/location/{protocol}?";
        if (protocol === undefined || protocol === null)
            throw new Error("The parameter 'protocol' must be defined.");
        url_ = url_.replace("{protocol}", encodeURIComponent("" + protocol));
        if (searchFields !== undefined && searchFields !== null)
            url_ += "searchFields=" + encodeURIComponent("" + searchFields) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQueryLocationByProtocol(_response);
        });
    }

    protected processQueryLocationByProtocol(response: Response): Promise<Location2[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Location2[];
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error86;
            return throwException("No portal rooms were found.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Location2[]>(null as any);
    }

    /**
     * Retrieve metadata about a specific protocol that the homeserver supports.
     * @param protocol The name of the protocol.
     * @return The protocol was found and metadata returned.
     */
    getProtocolMetadata(protocol: string): Promise<Protocol> {
        let url_ = this.baseUrl + "/_matrix/client/v3/thirdparty/protocol/{protocol}";
        if (protocol === undefined || protocol === null)
            throw new Error("The parameter 'protocol' must be defined.");
        url_ = url_.replace("{protocol}", encodeURIComponent("" + protocol));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProtocolMetadata(_response);
        });
    }

    protected processGetProtocolMetadata(response: Response): Promise<Protocol> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Protocol;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error87;
            return throwException("The protocol is unknown.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Protocol>(null as any);
    }

    /**
     * Retrieve metadata about all protocols that a homeserver supports.
     * @return The protocols supported by the homeserver.
     */
    getProtocols(): Promise<{ [key: string]: Protocol2; }> {
        let url_ = this.baseUrl + "/_matrix/client/v3/thirdparty/protocols";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProtocols(_response);
        });
    }

    protected processGetProtocols(response: Response): Promise<{ [key: string]: Protocol2; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as { [key: string]: Protocol2; };
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: Protocol2; }>(null as any);
    }

    /**
     * Reverse-lookup third party users given a Matrix User ID.
     * @param userid The Matrix User ID to look up.
     * @return An array of third party users.
     */
    queryUserByID(userid: string): Promise<User[]> {
        let url_ = this.baseUrl + "/_matrix/client/v3/thirdparty/user?";
        if (userid === undefined || userid === null)
            throw new Error("The parameter 'userid' must be defined and cannot be null.");
        else
            url_ += "userid=" + encodeURIComponent("" + userid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQueryUserByID(_response);
        });
    }

    protected processQueryUserByID(response: Response): Promise<User[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as User[];
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error88;
            return throwException("The Matrix User ID was not found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User[]>(null as any);
    }

    /**
     * Retrieve the Matrix User ID of a corresponding third party user.
     * @param protocol The name of the protocol.
     * @param fields___ (optional) One or more custom fields that are passed to the AS to help identify the user.
     * @return The Matrix User IDs found with the given parameters.
     */
    queryUserByProtocol(protocol: string, fields___?: string | null | undefined): Promise<User2[]> {
        let url_ = this.baseUrl + "/_matrix/client/v3/thirdparty/user/{protocol}?";
        if (protocol === undefined || protocol === null)
            throw new Error("The parameter 'protocol' must be defined.");
        url_ = url_.replace("{protocol}", encodeURIComponent("" + protocol));
        if (fields___ !== undefined && fields___ !== null)
            url_ += "fields...=" + encodeURIComponent("" + fields___) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processQueryUserByProtocol(_response);
        });
    }

    protected processQueryUserByProtocol(response: Response): Promise<User2[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as User2[];
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error89;
            return throwException("The Matrix User ID was not found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User2[]>(null as any);
    }

    /**
     * Get some account data for the user.
     * @param userId The ID of the user to get account data for. The access token must be
    authorized to make requests for this user ID.
     * @param type The event type of the account data to get. Custom types should be
    namespaced to avoid clashes.
     * @return The account data content for the given type.
     */
    getAccountData(userId: string, type: string): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/user/{userId}/account_data/{type}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAccountData(_response);
        });
    }

    protected processGetAccountData(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error90;
            return throwException("The access token provided is not authorized to retrieve this user\'s account \ndata. Errcode: `M_FORBIDDEN`.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error91;
            return throwException("No account data has been provided for this user with the given `type`.\nErrcode: `M_NOT_FOUND`.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Set some account data for the user.
     * @param userId The ID of the user to set account data for. The access token must be
    authorized to make requests for this user ID.
     * @param type The event type of the account data to set. Custom types should be
    namespaced to avoid clashes.
     * @param content The content of the account data.
     * @return The account data was successfully added.
     */
    setAccountData(userId: string, type: string, content: any): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/user/{userId}/account_data/{type}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(content);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetAccountData(_response);
        });
    }

    protected processSetAccountData(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error92;
            return throwException("The request body is not a JSON object. Errcode: `M_BAD_JSON`\nor `M_NOT_JSON`.", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error93;
            return throwException("The access token provided is not authorized to modify this user\'s account \ndata. Errcode: `M_FORBIDDEN`.", status, _responseText, _headers, result403);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            let result405: any = null;
            result405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error94;
            return throwException("This `type` of account data is controlled by the server; it cannot be\nmodified by clients. Errcode: `M_BAD_JSON`.", status, _responseText, _headers, result405);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Upload a new filter.
     * @param userId The id of the user uploading the filter. The access token must be authorized to make requests for this user id.
     * @param filter The filter to upload.
     * @return The filter was created.
     */
    defineFilter(userId: string, filter: Filter): Promise<Anonymous70> {
        let url_ = this.baseUrl + "/_matrix/client/v3/user/{userId}/filter";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(filter);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDefineFilter(_response);
        });
    }

    protected processDefineFilter(response: Response): Promise<Anonymous70> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous70;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous70>(null as any);
    }

    /**
     * Download a filter
     * @param userId The user ID to download a filter for.
     * @param filterId The filter ID to download.
     * @return The filter definition.
     */
    getFilter(userId: string, filterId: string): Promise<Anonymous71> {
        let url_ = this.baseUrl + "/_matrix/client/v3/user/{userId}/filter/{filterId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (filterId === undefined || filterId === null)
            throw new Error("The parameter 'filterId' must be defined.");
        url_ = url_.replace("{filterId}", encodeURIComponent("" + filterId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFilter(_response);
        });
    }

    protected processGetFilter(response: Response): Promise<Anonymous71> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous71;
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Unknown filter.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous71>(null as any);
    }

    /**
     * Get an OpenID token object to verify the requester's identity.
     * @param userId The user to request and OpenID token for. Should be the user who
    is authenticated for the request.
     * @param body An empty object. Reserved for future expansion.
     * @return OpenID token information. This response is nearly compatible with the
    response documented in the
    [OpenID Connect 1.0 Specification](http://openid.net/specs/openid-connect-core-1_0.html#TokenResponse)
    with the only difference being the lack of an `id_token`. Instead,
    the Matrix homeserver's name is provided.
     */
    requestOpenIdToken(userId: string, body: any): Promise<OpenIdCredentials> {
        let url_ = this.baseUrl + "/_matrix/client/v3/user/{userId}/openid/request_token";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestOpenIdToken(_response);
        });
    }

    protected processRequestOpenIdToken(response: Response): Promise<OpenIdCredentials> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as OpenIdCredentials;
            return result200;
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError46;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OpenIdCredentials>(null as any);
    }

    /**
     * Get some account data for the user that is specific to a room.
     * @param userId The ID of the user to get account data for. The access token must be
    authorized to make requests for this user ID.
     * @param roomId The ID of the room to get account data for.
     * @param type The event type of the account data to get. Custom types should be
    namespaced to avoid clashes.
     * @return The account data content for the given type.
     */
    getAccountDataPerRoom(userId: string, roomId: string, type: string): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/user/{userId}/rooms/{roomId}/account_data/{type}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAccountDataPerRoom(_response);
        });
    }

    protected processGetAccountDataPerRoom(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("The given `roomID` is not a valid room ID. Errcode: `M_INVALID_PARAM`.", status, _responseText, _headers);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error95;
            return throwException("The access token provided is not authorized to retrieve this user\'s account \ndata. Errcode: `M_FORBIDDEN`.", status, _responseText, _headers, result403);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error96;
            return throwException("No account data has been provided for this user and this room with the \ngiven `type`. Errcode: `M_NOT_FOUND`.", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Set some account data for the user that is specific to a room.
     * @param userId The ID of the user to set account data for. The access token must be
    authorized to make requests for this user ID.
     * @param roomId The ID of the room to set account data on.
     * @param type The event type of the account data to set. Custom types should be
    namespaced to avoid clashes.
     * @param content The content of the account data.
     * @return The account data was successfully added.
     */
    setAccountDataPerRoom(userId: string, roomId: string, type: string, content: any): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/user/{userId}/rooms/{roomId}/account_data/{type}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(content);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetAccountDataPerRoom(_response);
        });
    }

    protected processSetAccountDataPerRoom(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error97;
            return throwException("The request body is not a JSON object (errcode `M_BAD_JSON` or\n`M_NOT_JSON`), or the given `roomID` is not a valid room ID\n(errcode `M_INVALID_PARAM`).", status, _responseText, _headers, result400);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error98;
            return throwException("The access token provided is not authorized to modify this user\'s account \ndata. Errcode: `M_FORBIDDEN`.", status, _responseText, _headers, result403);
            });
        } else if (status === 405) {
            return response.text().then((_responseText) => {
            let result405: any = null;
            result405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error99;
            return throwException("This `type` of account data is controlled by the server; it cannot be\nmodified by clients. Errcode: `M_BAD_JSON`.", status, _responseText, _headers, result405);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * List the tags for a room.
     * @param userId The id of the user to get tags for. The access token must be
    authorized to make requests for this user ID.
     * @param roomId The ID of the room to get tags for.
     * @return The list of tags for the user for the room.
     */
    getRoomTags(userId: string, roomId: string): Promise<Anonymous72> {
        let url_ = this.baseUrl + "/_matrix/client/v3/user/{userId}/rooms/{roomId}/tags";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRoomTags(_response);
        });
    }

    protected processGetRoomTags(response: Response): Promise<Anonymous72> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous72;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous72>(null as any);
    }

    /**
     * Remove a tag from the room.
     * @param userId The id of the user to remove a tag for. The access token must be
    authorized to make requests for this user ID.
     * @param roomId The ID of the room to remove a tag from.
     * @param tag The tag to remove.
     * @return The tag was successfully removed.
     */
    deleteRoomTag(userId: string, roomId: string, tag: string): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/user/{userId}/rooms/{roomId}/tags/{tag}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        if (tag === undefined || tag === null)
            throw new Error("The parameter 'tag' must be defined.");
        url_ = url_.replace("{tag}", encodeURIComponent("" + tag));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteRoomTag(_response);
        });
    }

    protected processDeleteRoomTag(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Add a tag to a room.
     * @param userId The id of the user to add a tag for. The access token must be
    authorized to make requests for this user ID.
     * @param roomId The ID of the room to add a tag to.
     * @param tag The tag to add.
     * @param body Extra data for the tag, e.g. ordering.
     * @return The tag was successfully added.
     */
    setRoomTag(userId: string, roomId: string, tag: string, body: Body42): Promise<any> {
        let url_ = this.baseUrl + "/_matrix/client/v3/user/{userId}/rooms/{roomId}/tags/{tag}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (roomId === undefined || roomId === null)
            throw new Error("The parameter 'roomId' must be defined.");
        url_ = url_.replace("{roomId}", encodeURIComponent("" + roomId));
        if (tag === undefined || tag === null)
            throw new Error("The parameter 'tag' must be defined.");
        url_ = url_.replace("{tag}", encodeURIComponent("" + tag));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetRoomTag(_response);
        });
    }

    protected processSetRoomTag(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as any;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(null as any);
    }

    /**
     * Searches the user directory.
     * @return The results of the search.
     */
    searchUserDirectory(body: Body43): Promise<Anonymous73> {
        let url_ = this.baseUrl + "/_matrix/client/v3/user_directory/search";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchUserDirectory(_response);
        });
    }

    protected processSearchUserDirectory(response: Response): Promise<Anonymous73> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous73;
            return result200;
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError47;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous73>(null as any);
    }

    /**
     * Obtain TURN server credentials.
     * @return The TURN server credentials.
     */
    getTurnServer(): Promise<Anonymous74> {
        let url_ = this.baseUrl + "/_matrix/client/v3/voip/turnServer";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTurnServer(_response);
        });
    }

    protected processGetTurnServer(response: Response): Promise<Anonymous74> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous74;
            return result200;
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError48;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous74>(null as any);
    }

    /**
     * Gets the versions of the specification supported by the server.
     * @return The versions supported by the server.
     */
    getVersions(): Promise<Anonymous75> {
        let url_ = this.baseUrl + "/_matrix/client/versions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetVersions(_response);
        });
    }

    protected processGetVersions(response: Response): Promise<Anonymous75> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous75;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous75>(null as any);
    }

    /**
     * Get the configuration for the content repository.
     * @return The public content repository configuration for the matrix server.
     */
    getConfig(): Promise<Anonymous76> {
        let url_ = this.baseUrl + "/_matrix/media/v3/config";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetConfig(_response);
        });
    }

    protected processGetConfig(response: Response): Promise<Anonymous76> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous76;
            return result200;
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error100;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous76>(null as any);
    }

    /**
     * Download content from the content repository.
     * @param serverName The server name from the `mxc://` URI (the authoritory component)
     * @param mediaId The media ID from the `mxc://` URI (the path component)
     * @param allow_remote (optional) Indicates to the server that it should not attempt to fetch the media if it is deemed
    remote. This is to prevent routing loops where the server contacts itself. Defaults to
    true if not provided.
     * @return The content that was previously uploaded.
     */
    getContent(serverName: string, mediaId: string, allow_remote?: boolean | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/_matrix/media/v3/download/{serverName}/{mediaId}?";
        if (serverName === undefined || serverName === null)
            throw new Error("The parameter 'serverName' must be defined.");
        url_ = url_.replace("{serverName}", encodeURIComponent("" + serverName));
        if (mediaId === undefined || mediaId === null)
            throw new Error("The parameter 'mediaId' must be defined.");
        url_ = url_.replace("{mediaId}", encodeURIComponent("" + mediaId));
        if (allow_remote !== undefined && allow_remote !== null)
            url_ += "allow_remote=" + encodeURIComponent("" + allow_remote) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContent(_response);
        });
    }

    protected processGetContent(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError49;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status === 502) {
            return response.text().then((_responseText) => {
            let result502: any = null;
            result502 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error101;
            return throwException("The content is too large for the server to serve.", status, _responseText, _headers, result502);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Download content from the content repository overriding the file name
     * @param serverName The server name from the `mxc://` URI (the authoritory component)
     * @param mediaId The media ID from the `mxc://` URI (the path component)
     * @param fileName A filename to give in the `Content-Disposition` header.
     * @param allow_remote (optional) Indicates to the server that it should not attempt to fetch the media if it is deemed
    remote. This is to prevent routing loops where the server contacts itself. Defaults to
    true if not provided.
     * @return The content that was previously uploaded.
     */
    getContentOverrideName(serverName: string, mediaId: string, fileName: string, allow_remote?: boolean | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/_matrix/media/v3/download/{serverName}/{mediaId}/{fileName}?";
        if (serverName === undefined || serverName === null)
            throw new Error("The parameter 'serverName' must be defined.");
        url_ = url_.replace("{serverName}", encodeURIComponent("" + serverName));
        if (mediaId === undefined || mediaId === null)
            throw new Error("The parameter 'mediaId' must be defined.");
        url_ = url_.replace("{mediaId}", encodeURIComponent("" + mediaId));
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        if (allow_remote !== undefined && allow_remote !== null)
            url_ += "allow_remote=" + encodeURIComponent("" + allow_remote) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "*/*"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContentOverrideName(_response);
        });
    }

    protected processGetContentOverrideName(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError50;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status === 502) {
            return response.text().then((_responseText) => {
            let result502: any = null;
            result502 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error102;
            return throwException("The content is too large for the server to serve.", status, _responseText, _headers, result502);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Get information about a URL for a client
     * @param url The URL to get a preview of.
     * @param ts (optional) The preferred point in time to return a preview for. The server may
    return a newer version if it does not have the requested version
    available.
     * @return The OpenGraph data for the URL, which may be empty. Some values are
    replaced with matrix equivalents if they are provided in the response.
    The differences from the OpenGraph protocol are described here.
     */
    getUrlPreview(url: string, ts?: number | null | undefined): Promise<Anonymous77> {
        let url_ = this.baseUrl + "/_matrix/media/v3/preview_url?";
        if (url === undefined || url === null)
            throw new Error("The parameter 'url' must be defined and cannot be null.");
        else
            url_ += "url=" + encodeURIComponent("" + url) + "&";
        if (ts !== undefined && ts !== null)
            url_ += "ts=" + encodeURIComponent("" + ts) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUrlPreview(_response);
        });
    }

    protected processGetUrlPreview(response: Response): Promise<Anonymous77> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous77;
            return result200;
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError51;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous77>(null as any);
    }

    /**
     * Download a thumbnail of content from the content repository
     * @param serverName The server name from the `mxc://` URI (the authoritory component)
     * @param mediaId The media ID from the `mxc://` URI (the path component)
     * @param width The *desired* width of the thumbnail. The actual thumbnail may be
    larger than the size specified.
     * @param height The *desired* height of the thumbnail. The actual thumbnail may be
    larger than the size specified.
     * @param method (optional) The desired resizing method. See the [Thumbnails](https://spec.matrix.org/v1.5/client-server-api/#thumbnails)
    section for more information.
     * @param allow_remote (optional) Indicates to the server that it should not attempt to fetch
    the media if it is deemed remote. This is to prevent routing loops
    where the server contacts itself. Defaults to true if not provided.
     * @return A thumbnail of the requested content.
     */
    getContentThumbnail(serverName: string, mediaId: string, width: number, height: number, method?: Method | null | undefined, allow_remote?: boolean | null | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/_matrix/media/v3/thumbnail/{serverName}/{mediaId}?";
        if (serverName === undefined || serverName === null)
            throw new Error("The parameter 'serverName' must be defined.");
        url_ = url_.replace("{serverName}", encodeURIComponent("" + serverName));
        if (mediaId === undefined || mediaId === null)
            throw new Error("The parameter 'mediaId' must be defined.");
        url_ = url_.replace("{mediaId}", encodeURIComponent("" + mediaId));
        if (width === undefined || width === null)
            throw new Error("The parameter 'width' must be defined and cannot be null.");
        else
            url_ += "width=" + encodeURIComponent("" + width) + "&";
        if (height === undefined || height === null)
            throw new Error("The parameter 'height' must be defined and cannot be null.");
        else
            url_ += "height=" + encodeURIComponent("" + height) + "&";
        if (method !== undefined && method !== null)
            url_ += "method=" + encodeURIComponent("" + method) + "&";
        if (allow_remote !== undefined && allow_remote !== null)
            url_ += "allow_remote=" + encodeURIComponent("" + allow_remote) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "image/jpeg"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContentThumbnail(_response);
        });
    }

    protected processGetContentThumbnail(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error103;
            return throwException("The request does not make sense to the server, or the server cannot thumbnail\nthe content. For example, the client requested non-integer dimensions or asked\nfor negatively-sized images.", status, _responseText, _headers, result400);
            });
        } else if (status === 413) {
            return response.text().then((_responseText) => {
            let result413: any = null;
            result413 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error104;
            return throwException("The local content is too large for the server to thumbnail.", status, _responseText, _headers, result413);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError52;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status === 502) {
            return response.text().then((_responseText) => {
            let result502: any = null;
            result502 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error105;
            return throwException("The remote content is too large for the server to thumbnail.", status, _responseText, _headers, result502);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * Upload some content to the content repository.
     * @param content The content to be uploaded.
     * @param content_Type (optional) The content type of the file being uploaded
     * @param filename (optional) The name of the file being uploaded
     * @return The [MXC URI](https://spec.matrix.org/v1.5/client-server-api/#matrix-content-mxc-uris) for the uploaded content.
     */
    uploadContent(content: string, content_Type?: string | null | undefined, filename?: string | null | undefined): Promise<Anonymous78> {
        let url_ = this.baseUrl + "/_matrix/media/v3/upload?";
        if (filename !== undefined && filename !== null)
            url_ += "filename=" + encodeURIComponent("" + filename) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(content);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": content_Type !== undefined && content_Type !== null ? "" + content_Type : "",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadContent(_response);
        });
    }

    protected processUploadContent(response: Response): Promise<Anonymous78> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Anonymous78;
            return result200;
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error106;
            return throwException("The user does not have permission to upload the content. Some reasons for this error include:\n\n- The server does not permit the file type.\n- The user has reached a quota for uploaded content.", status, _responseText, _headers, result403);
            });
        } else if (status === 413) {
            return response.text().then((_responseText) => {
            let result413: any = null;
            result413 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Error107;
            return throwException("The uploaded content is too large for the server.", status, _responseText, _headers, result413);
            });
        } else if (status === 429) {
            return response.text().then((_responseText) => {
            let result429: any = null;
            result429 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RateLimitError53;
            return throwException("This request was rate-limited.", status, _responseText, _headers, result429);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Anonymous78>(null as any);
    }
}

/** Optional (default `b`) direction to return events from. If this is set to `f`, events will be returned in chronological order starting at `from`. If it is set to `b`, events will be returned in *reverse* chronological order, again starting at `from`. */
export enum Dir {
    B = "b",
    F = "f",
}

/** Optional (default `b`) direction to return events from. If this is set to `f`, events will be returned in chronological order starting at `from`. If it is set to `b`, events will be returned in *reverse* chronological order, again starting at `from`. */
export enum Dir2 {
    B = "b",
    F = "f",
}

/** Optional (default `b`) direction to return events from. If this is set to `f`, events will be returned in chronological order starting at `from`. If it is set to `b`, events will be returned in *reverse* chronological order, again starting at `from`. */
export enum Dir3 {
    B = "b",
    F = "f",
}

/** Optional (default `all`) flag to denote which thread roots are of interest to the caller. When `all`, all thread roots found in the room are returned. When `participated`, only thread roots for threads the user has [participated in](https://spec.matrix.org/v1.5/client-server-api/#server-side-aggregation-of-mthread-relationships) will be returned. */
export enum Include {
    All = "all",
    Participated = "participated",
}

export interface Body {
    /** The third party credentials to associate with the account. */
    three_pid_creds: Three_pid_creds;
}

export interface Body2 {
    /** Additional authentication information for the
user-interactive authentication API. */
    auth?: Auth | undefined;
    /** The client secret used in the session with the homeserver. */
    client_secret: string;
    /** The session identifier given by the homeserver. */
    sid: string;
}

export interface Body3 {
    /** The client secret used in the session with the identity server. */
    client_secret: string;
    /** An access token previously registered with the identity server. */
    id_access_token: string;
    /** The identity server to use. */
    id_server: string;
    /** The session identifier given by the identity server. */
    sid: string;
}

export interface Body4 {
    /** The third party address being removed. */
    address: string;
    /** The identity server to unbind from. If not provided, the homeserver
MUST use the `id_server` the identifier was added through. If the
homeserver does not know the original `id_server`, it MUST return
a `id_server_unbind_result` of `no-support`. */
    id_server?: string | undefined;
    /** The medium of the third party identifier being removed. */
    medium: Body4Medium;
}

export interface Anonymous79 {
    /** A unique string generated by the client, and used to identify the
validation attempt. It must be a string consisting of the characters
`[0-9a-zA-Z.=_-]`. Its length must not exceed 255 characters and it
must not be empty.
 */
    client_secret: string;
    /** The email address to validate. */
    email: string;
    /** Optional. When the validation is completed, the identity server will
redirect the user to this URL. This option is ignored when submitting
3PID validation information through a POST request. */
    next_link?: string | undefined;
    /** The server will only send an email if the `send_attempt`
is a number greater than the most recent one which it has seen,
scoped to that `email` + `client_secret` pair. This is to
avoid repeatedly sending the same email in the case of request
retries between the POSTing user and the identity server.
The client should increment this value if they desire a new
email (e.g. a reminder) to be sent. If they do not, the server
should respond with success but not resend the email. */
    send_attempt: number;
}

export interface Body5 extends Anonymous79 {
    /** An access token previously registered with the identity server. Servers
can treat this as optional to distinguish between r0.5-compatible clients
and this specification version.

Required if an `id_server` is supplied. */
    id_access_token?: string | undefined;
    /** The hostname of the identity server to communicate with. May optionally
include a port. This parameter is ignored when the homeserver handles
3PID verification.

This parameter is deprecated with a plan to be removed in a future specification
version for `/account/password` and `/register` requests. */
    id_server?: string | undefined;
}

export interface Anonymous80 {
    /** A unique string generated by the client, and used to identify the
validation attempt. It must be a string consisting of the characters
`[0-9a-zA-Z.=_-]`. Its length must not exceed 255 characters and it
must not be empty.
 */
    client_secret: string;
    /** The two-letter uppercase ISO-3166-1 alpha-2 country code that the
number in `phone_number` should be parsed as if it were dialled from. */
    country: string;
    /** Optional. When the validation is completed, the identity server will
redirect the user to this URL. This option is ignored when submitting
3PID validation information through a POST request. */
    next_link?: string | undefined;
    /** The phone number to validate. */
    phone_number: string;
    /** The server will only send an SMS if the `send_attempt` is a
number greater than the most recent one which it has seen,
scoped to that `country` + `phone_number` + `client_secret`
triple. This is to avoid repeatedly sending the same SMS in
the case of request retries between the POSTing user and the
identity server. The client should increment this value if
they desire a new SMS (e.g. a reminder) to be sent. */
    send_attempt: number;
}

export interface Body6 extends Anonymous80 {
    /** An access token previously registered with the identity server. Servers
can treat this as optional to distinguish between r0.5-compatible clients
and this specification version.

Required if an `id_server` is supplied. */
    id_access_token?: string | undefined;
    /** The hostname of the identity server to communicate with. May optionally
include a port. This parameter is ignored when the homeserver handles
3PID verification.

This parameter is deprecated with a plan to be removed in a future specification
version for `/account/password` and `/register` requests. */
    id_server?: string | undefined;
}

export interface Body7 {
    /** The third party address being removed. */
    address: string;
    /** The identity server to unbind from. If not provided, the homeserver
MUST use the `id_server` the identifier was added through. If the
homeserver does not know the original `id_server`, it MUST return
a `id_server_unbind_result` of `no-support`. */
    id_server?: string | undefined;
    /** The medium of the third party identifier being removed. */
    medium: Body7Medium;
}

export interface Body8 {
    /** Additional authentication information for the user-interactive authentication API. */
    auth?: Auth2 | undefined;
    /** The identity server to unbind all of the user's 3PIDs from.
If not provided, the homeserver MUST use the `id_server`
that was originally use to bind each identifier. If the
homeserver does not know which `id_server` that was,
it must return an `id_server_unbind_result` of
`no-support`. */
    id_server?: string | undefined;
}

export interface Body9 {
    /** Additional authentication information for the user-interactive authentication API. */
    auth?: Auth3 | undefined;
    /** Whether the user's other access tokens, and their associated devices, should be
revoked if the request succeeds. Defaults to true.

When `false`, the server can still take advantage of the [soft logout method](https://spec.matrix.org/v1.5/client-server-api/#soft-logout)
for the user's remaining devices. */
    logout_devices?: boolean | undefined;
    /** The new password for the account. */
    new_password: string;
}

export interface Anonymous81 {
    /** A unique string generated by the client, and used to identify the
validation attempt. It must be a string consisting of the characters
`[0-9a-zA-Z.=_-]`. Its length must not exceed 255 characters and it
must not be empty.
 */
    client_secret: string;
    /** The email address to validate. */
    email: string;
    /** Optional. When the validation is completed, the identity server will
redirect the user to this URL. This option is ignored when submitting
3PID validation information through a POST request. */
    next_link?: string | undefined;
    /** The server will only send an email if the `send_attempt`
is a number greater than the most recent one which it has seen,
scoped to that `email` + `client_secret` pair. This is to
avoid repeatedly sending the same email in the case of request
retries between the POSTing user and the identity server.
The client should increment this value if they desire a new
email (e.g. a reminder) to be sent. If they do not, the server
should respond with success but not resend the email. */
    send_attempt: number;
}

export interface Body10 extends Anonymous81 {
    /** An access token previously registered with the identity server. Servers
can treat this as optional to distinguish between r0.5-compatible clients
and this specification version.

Required if an `id_server` is supplied. */
    id_access_token?: string | undefined;
    /** The hostname of the identity server to communicate with. May optionally
include a port. This parameter is ignored when the homeserver handles
3PID verification.

This parameter is deprecated with a plan to be removed in a future specification
version for `/account/password` and `/register` requests. */
    id_server?: string | undefined;
}

export interface Anonymous82 {
    /** A unique string generated by the client, and used to identify the
validation attempt. It must be a string consisting of the characters
`[0-9a-zA-Z.=_-]`. Its length must not exceed 255 characters and it
must not be empty.
 */
    client_secret: string;
    /** The two-letter uppercase ISO-3166-1 alpha-2 country code that the
number in `phone_number` should be parsed as if it were dialled from. */
    country: string;
    /** Optional. When the validation is completed, the identity server will
redirect the user to this URL. This option is ignored when submitting
3PID validation information through a POST request. */
    next_link?: string | undefined;
    /** The phone number to validate. */
    phone_number: string;
    /** The server will only send an SMS if the `send_attempt` is a
number greater than the most recent one which it has seen,
scoped to that `country` + `phone_number` + `client_secret`
triple. This is to avoid repeatedly sending the same SMS in
the case of request retries between the POSTing user and the
identity server. The client should increment this value if
they desire a new SMS (e.g. a reminder) to be sent. */
    send_attempt: number;
}

export interface Body11 extends Anonymous82 {
    /** An access token previously registered with the identity server. Servers
can treat this as optional to distinguish between r0.5-compatible clients
and this specification version.

Required if an `id_server` is supplied. */
    id_access_token?: string | undefined;
    /** The hostname of the identity server to communicate with. May optionally
include a port. This parameter is ignored when the homeserver handles
3PID verification.

This parameter is deprecated with a plan to be removed in a future specification
version for `/account/password` and `/register` requests. */
    id_server?: string | undefined;
}

export interface Body12 {
    /** Extra keys, such as `m.federate`, to be added to the content
of the [`m.room.create`](https://spec.matrix.org/v1.5/client-server-api/#mroomcreate) event. The server will overwrite the following
keys: `creator`, `room_version`. Future versions of the specification
may allow the server to overwrite other keys. */
    creation_content?: any | undefined;
    /** A list of state events to set in the new room. This allows
the user to override the default state events set in the new
room. The expected format of the state events are an object
with type, state_key and content keys set.

Takes precedence over events set by `preset`, but gets
overridden by `name` and `topic` keys. */
    initial_state?: Initial_state[] | undefined;
    /** A list of user IDs to invite to the room. This will tell the
server to invite everyone in the list to the newly created room. */
    invite?: string[] | undefined;
    /** A list of objects representing third party IDs to invite into
the room. */
    invite_3pid?: Invite_3pid[] | undefined;
    /** This flag makes the server set the `is_direct` flag on the
`m.room.member` events sent to the users in `invite` and
`invite_3pid`. See [Direct Messaging](https://spec.matrix.org/v1.5/client-server-api/#direct-messaging) for more information. */
    is_direct?: boolean | undefined;
    /** If this is included, an `m.room.name` event will be sent
into the room to indicate the name of the room. See Room
Events for more information on `m.room.name`. */
    name?: string | undefined;
    /** The power level content to override in the default power level
event. This object is applied on top of the generated
[`m.room.power_levels`](https://spec.matrix.org/v1.5/client-server-api/#mroompower_levels)
event content prior to it being sent to the room. Defaults to
overriding nothing. */
    power_level_content_override?: any | undefined;
    /** Convenience parameter for setting various default state events
based on a preset.

If unspecified, the server should use the `visibility` to determine
which preset to use. A visbility of `public` equates to a preset of
`public_chat` and `private` visibility equates to a preset of
`private_chat`. */
    preset?: Body12Preset | undefined;
    /** The desired room alias **local part**. If this is included, a
room alias will be created and mapped to the newly created
room. The alias will belong on the *same* homeserver which
created the room. For example, if this was set to "foo" and
sent to the homeserver "example.com" the complete room alias
would be `#foo:example.com`.

The complete room alias will become the canonical alias for
the room and an `m.room.canonical_alias` event will be sent
into the room. */
    room_alias_name?: string | undefined;
    /** The room version to set for the room. If not provided, the homeserver is
to use its configured default. If provided, the homeserver will return a
400 error with the errcode `M_UNSUPPORTED_ROOM_VERSION` if it does not
support the room version. */
    room_version?: string | undefined;
    /** If this is included, an `m.room.topic` event will be sent
into the room to indicate the topic for the room. See Room
Events for more information on `m.room.topic`. */
    topic?: string | undefined;
    /** A `public` visibility indicates that the room will be shown
in the published room list. A `private` visibility will hide
the room from the published room list. Rooms default to
`private` visibility if this key is not included. NB: This
should not be confused with `join_rules` which also uses the
word `public`. */
    visibility?: Body12Visibility | undefined;
}

export interface Body13 {
    /** Additional authentication information for the
user-interactive authentication API. */
    auth?: Auth4 | undefined;
    /** The list of device IDs to delete. */
    devices: string[];
}

export interface Body14 {
    /** Additional authentication information for the
user-interactive authentication API. */
    auth?: Auth5 | undefined;
}

export interface Body15 {
    /** The new display name for this device. If not given, the
display name is unchanged. */
    display_name?: string | undefined;
}

export interface Body16 {
    /** Whether the room should be visible (public) in the directory
or not (private). */
    visibility: Body16Visibility;
}

export interface Body17 {
    /** The new visibility setting for the room.
Defaults to 'public'. */
    visibility?: Body17Visibility | undefined;
}

export interface Body18 {
    /** The room ID to set. */
    room_id: string;
}

export interface Body19 {
    /** Optional reason to be included as the `reason` on the subsequent
membership event. */
    reason?: string | undefined;
    /** If a `third_party_signed` was supplied, the homeserver must verify
that it matches a pending `m.room.third_party_invite` event in the
room, and perform key validity checking if required by the event. */
    third_party_signed?: Third_party_signed | undefined;
}

export interface Query {
    /** The keys to be claimed. A map from user ID, to a map from
device ID to algorithm name. */
    one_time_keys: { [key: string]: { [key: string]: string; }; };
    /** The time (in milliseconds) to wait when downloading keys from
remote servers. 10 seconds is the recommended default. */
    timeout?: number | undefined;
}

export interface Keys {
    /** Additional authentication information for the
user-interactive authentication API. */
    auth?: Auth6 | undefined;
    /** Optional. The user\'s master key. */
    master_key?: Master_key | undefined;
    /** Optional. The user\'s self-signing key. Must be signed by
the accompanying master key, or by the user\'s most recently
uploaded master key if no master key is included in the
request. */
    self_signing_key?: Self_signing_key | undefined;
    /** Optional. The user\'s user-signing key. Must be signed by
the accompanying master key, or by the user\'s most recently
uploaded master key if no master key is included in the
request. */
    user_signing_key?: User_signing_key | undefined;
}

export interface Query2 {
    /** The keys to be downloaded. A map from user ID, to a list of
device IDs, or to an empty list to indicate all devices for the
corresponding user. */
    device_keys: { [key: string]: string[]; };
    /** The time (in milliseconds) to wait when downloading keys from
remote servers. 10 seconds is the recommended default. */
    timeout?: number | undefined;
    /** If the client is fetching keys as a result of a device update received
in a sync request, this should be the 'since' token of that sync request,
or any later sync token. This allows the server to ensure its response
contains the keys advertised by the notification in that sync. */
    token?: string | undefined;
}

export interface Keys2 {
    /** Identity keys for the device. May be absent if no new
identity keys are required. */
    device_keys?: Device_keys | undefined;
    /** The public key which should be used if the device's one-time keys
are exhausted. The fallback key is not deleted once used, but should
be replaced when additional one-time keys are being uploaded. The
server will notify the client of the fallback key being used through
`/sync`.

There can only be at most one key per algorithm uploaded, and the server
will only persist one key per algorithm.

When uploading a signed key, an additional `fallback: true` key should
be included to denote that the key is a fallback key.

May be absent if a new fallback key is not required. */
    fallback_keys?: any | undefined;
    /** One-time public keys for "pre-key" messages.  The names of
the properties should be in the format
`<algorithm>:<key_id>`. The format of the key is determined
by the [key algorithm](https://spec.matrix.org/v1.5/client-server-api/#key-algorithms).

May be absent if no new one-time keys are required. */
    one_time_keys?: any | undefined;
}

export interface Body20 {
    /** Optional reason to be included as the `reason` on the subsequent
membership event. */
    reason?: string | undefined;
}

export interface Body21 {
    /** Third party identifier for the user.  Deprecated in favour of `identifier`. */
    address?: string | undefined;
    /** ID of the client device. If this does not correspond to a
known client device, a new device will be created. The given
device ID must not be the same as a
[cross-signing](https://spec.matrix.org/v1.5/client-server-api/#cross-signing) key ID.
The server will auto-generate a device_id
if this is not specified. */
    device_id?: string | undefined;
    /** Identification information for a user */
    identifier?: Identifier | undefined;
    /** A display name to assign to the newly-created device. Ignored
if `device_id` corresponds to a known device. */
    initial_device_display_name?: string | undefined;
    /** When logging in using a third party identifier, the medium of the identifier. Must be 'email'.  Deprecated in favour of `identifier`. */
    medium?: string | undefined;
    /** Required when `type` is `m.login.password`. The user's
password. */
    password?: string | undefined;
    /** If true, the client supports refresh tokens. */
    refresh_token?: boolean | undefined;
    /** Required when `type` is `m.login.token`. Part of Token-based login. */
    token?: string | undefined;
    /** The login type being used. */
    type: Body21Type;
    /** The fully qualified user ID or just local part of the user ID, to log in.  Deprecated in favour of `identifier`. */
    user?: string | undefined;
}

export interface PresenceState {
    /** The new presence state. */
    presence: PresenceStatePresence;
    /** The status message to attach to this state. */
    status_msg?: string | undefined;
}

export interface Avatar_url {
    /** The new avatar URL for this user. */
    avatar_url?: string | undefined;
}

export interface DisplayName {
    /** The new display name for this user. */
    displayname?: string | undefined;
}

export interface Body22 {
    /** Filter to apply to the results. */
    filter?: Filter2 | undefined;
    /** Whether or not to include all known networks/protocols from
application services on the homeserver. Defaults to false. */
    include_all_networks?: boolean | undefined;
    /** Limit the number of results returned. */
    limit?: number | undefined;
    /** A pagination token from a previous request, allowing clients
to get the next (or previous) batch of rooms.  The direction
of pagination is specified solely by which token is supplied,
rather than via an explicit flag. */
    since?: string | undefined;
    /** The specific third party network/protocol to request from the
homeserver. Can only be used if `include_all_networks` is false. */
    third_party_instance_id?: string | undefined;
}

export interface Pusher {
    /** A string that will allow the user to identify what application
owns this pusher. */
    app_display_name: string;
    /** This is a reverse-DNS style identifier for the application.
It is recommended that this end with the platform, such that
different platform versions get different app identifiers.
Max length, 64 chars.

If the `kind` is `"email"`, this is `"m.email"`. */
    app_id: string;
    /** If true, the homeserver should add another pusher with the
given pushkey and App ID in addition to any others with
different user IDs. Otherwise, the homeserver must remove any
other pushers with the same App ID and pushkey for different
users. The default is `false`. */
    append?: boolean | undefined;
    /** A dictionary of information for the pusher implementation
itself. If `kind` is `http`, this should contain `url`
which is the URL to use to send notifications to. */
    data: Data;
    /** A string that will allow the user to identify what device owns
this pusher. */
    device_display_name: string;
    /** The kind of pusher to configure. `"http"` makes a pusher that
sends HTTP pokes. `"email"` makes a pusher that emails the
user with unread notifications. `null` deletes the pusher. */
    kind: string;
    /** The preferred language for receiving notifications (e.g. 'en'
or 'en-US'). */
    lang: string;
    /** This string determines which set of device specific rules this
pusher executes. */
    profile_tag?: string | undefined;
    /** This is a unique identifier for this pusher. The value you
should use for this is the routing or destination address
information for the notification, for example, the APNS token
for APNS or the Registration ID for GCM. If your notification
client has no such concept, use any unique identifier.
Max length, 512 bytes.

If the `kind` is `"email"`, this is the email address to
send notifications to. */
    pushkey: string;
}

/** The kind of rule */
export enum Kind {
    Override = "override",
    Underride = "underride",
    Sender = "sender",
    Room = "room",
    Content = "content",
}

/** The kind of rule */
export enum Kind2 {
    Override = "override",
    Underride = "underride",
    Sender = "sender",
    Room = "room",
    Content = "content",
}

/** The kind of rule */
export enum Kind3 {
    Override = "override",
    Underride = "underride",
    Sender = "sender",
    Room = "room",
    Content = "content",
}

export interface Pushrule {
    /** The action(s) to perform when the conditions for this rule are met. */
    actions: any[];
    /** The conditions that must hold true for an event in order for a
rule to be applied to an event. A rule with no conditions
always matches. Only applicable to `underride` and `override` rules. */
    conditions?: Conditions[] | undefined;
    /** Only applicable to `content` rules. The glob-style pattern to match against. */
    pattern?: string | undefined;
}

/** The kind of rule */
export enum Kind4 {
    Override = "override",
    Underride = "underride",
    Sender = "sender",
    Room = "room",
    Content = "content",
}

/** The kind of rule */
export enum Kind5 {
    Override = "override",
    Underride = "underride",
    Sender = "sender",
    Room = "room",
    Content = "content",
}

export interface Body23 {
    /** The action(s) to perform for this rule. */
    actions: any[];
}

/** The kind of rule */
export enum Kind6 {
    Override = "override",
    Underride = "underride",
    Sender = "sender",
    Room = "room",
    Content = "content",
}

/** The kind of rule */
export enum Kind7 {
    Override = "override",
    Underride = "underride",
    Sender = "sender",
    Room = "room",
    Content = "content",
}

export interface Body24 {
    /** Whether the push rule is enabled or not. */
    enabled: boolean;
}

export interface Body25 {
    /** The refresh token */
    refresh_token: string;
}

export interface Body26 {
    /** Additional authentication information for the
user-interactive authentication API. Note that this
information is *not* used to define how the registered user
should be authenticated, but is instead used to
authenticate the `register` call itself. */
    auth?: Auth7 | undefined;
    /** ID of the client device. If this does not correspond to a
known client device, a new device will be created. The server
will auto-generate a device_id if this is not specified. */
    device_id?: string | undefined;
    /** If true, an `access_token` and `device_id` should not be
returned from this call, therefore preventing an automatic
login. Defaults to false. */
    inhibit_login?: boolean | undefined;
    /** A display name to assign to the newly-created device. Ignored
if `device_id` corresponds to a known device. */
    initial_device_display_name?: string | undefined;
    /** The desired password for the account. */
    password?: string | undefined;
    /** If true, the client supports refresh tokens. */
    refresh_token?: boolean | undefined;
    /** The basis for the localpart of the desired Matrix ID. If omitted,
the homeserver MUST generate a Matrix ID local part. */
    username?: string | undefined;
}

/** The kind of account to register. Defaults to `user`. */
export enum Kind8 {
    Guest = "guest",
    User = "user",
}

export interface Anonymous83 {
    /** A unique string generated by the client, and used to identify the
validation attempt. It must be a string consisting of the characters
`[0-9a-zA-Z.=_-]`. Its length must not exceed 255 characters and it
must not be empty.
 */
    client_secret: string;
    /** The email address to validate. */
    email: string;
    /** Optional. When the validation is completed, the identity server will
redirect the user to this URL. This option is ignored when submitting
3PID validation information through a POST request. */
    next_link?: string | undefined;
    /** The server will only send an email if the `send_attempt`
is a number greater than the most recent one which it has seen,
scoped to that `email` + `client_secret` pair. This is to
avoid repeatedly sending the same email in the case of request
retries between the POSTing user and the identity server.
The client should increment this value if they desire a new
email (e.g. a reminder) to be sent. If they do not, the server
should respond with success but not resend the email. */
    send_attempt: number;
}

export interface Body27 extends Anonymous83 {
    /** An access token previously registered with the identity server. Servers
can treat this as optional to distinguish between r0.5-compatible clients
and this specification version.

Required if an `id_server` is supplied. */
    id_access_token?: string | undefined;
    /** The hostname of the identity server to communicate with. May optionally
include a port. This parameter is ignored when the homeserver handles
3PID verification.

This parameter is deprecated with a plan to be removed in a future specification
version for `/account/password` and `/register` requests. */
    id_server?: string | undefined;
}

export interface Anonymous84 {
    /** A unique string generated by the client, and used to identify the
validation attempt. It must be a string consisting of the characters
`[0-9a-zA-Z.=_-]`. Its length must not exceed 255 characters and it
must not be empty.
 */
    client_secret: string;
    /** The two-letter uppercase ISO-3166-1 alpha-2 country code that the
number in `phone_number` should be parsed as if it were dialled from. */
    country: string;
    /** Optional. When the validation is completed, the identity server will
redirect the user to this URL. This option is ignored when submitting
3PID validation information through a POST request. */
    next_link?: string | undefined;
    /** The phone number to validate. */
    phone_number: string;
    /** The server will only send an SMS if the `send_attempt` is a
number greater than the most recent one which it has seen,
scoped to that `country` + `phone_number` + `client_secret`
triple. This is to avoid repeatedly sending the same SMS in
the case of request retries between the POSTing user and the
identity server. The client should increment this value if
they desire a new SMS (e.g. a reminder) to be sent. */
    send_attempt: number;
}

export interface Body28 extends Anonymous84 {
    /** An access token previously registered with the identity server. Servers
can treat this as optional to distinguish between r0.5-compatible clients
and this specification version.

Required if an `id_server` is supplied. */
    id_access_token?: string | undefined;
    /** The hostname of the identity server to communicate with. May optionally
include a port. This parameter is ignored when the homeserver handles
3PID verification.

This parameter is deprecated with a plan to be removed in a future specification
version for `/account/password` and `/register` requests. */
    id_server?: string | undefined;
}

export interface BackupData {
    /** A map of room IDs to room key backup data. */
    rooms: { [key: string]: Anonymous85; };
}

/** The backed up keys for a room. */
export interface RoomKeyBackup {
    /** A map of session IDs to key data. */
    sessions: { [key: string]: Anonymous86; };
}

/** The key data */
export interface KeyBackupData {
    /** The index of the first message in the session that the key can decrypt. */
    first_message_index: number;
    /** The number of times this key has been forwarded via key-sharing between devices. */
    forwarded_count: number;
    /** Whether the device backing up the key verified the device that the key
is from. */
    is_verified: boolean;
    /** Algorithm-dependent data.  See the documentation for the backup
algorithms in [Server-side key backups](https://spec.matrix.org/v1.5/client-server-api/#server-side-key-backups) for more information on the
expected format of the data. */
    session_data: any;
}

export interface Version {
    /** The algorithm used for storing backups. */
    algorithm: VersionAlgorithm;
    /** Algorithm-dependent data. See the documentation for the backup
algorithms in [Server-side key backups](https://spec.matrix.org/v1.5/client-server-api/#server-side-key-backups) for more information on the
expected format of the data. */
    auth_data: any;
}

export interface Version2 {
    /** The algorithm used for storing backups.  Must be the same as
the algorithm currently used by the backup. */
    algorithm: Version2Algorithm;
    /** Algorithm-dependent data. See the documentation for the backup
algorithms in [Server-side key backups](https://spec.matrix.org/v1.5/client-server-api/#server-side-key-backups) for more information on the
expected format of the data. */
    auth_data: any;
    /** The backup version.  If present, must be the same as the
version in the path parameter. */
    version?: string | undefined;
}

export interface Body29 {
    /** The reason the user has been banned. This will be supplied as the `reason` on the target's updated [`m.room.member`](https://spec.matrix.org/v1.5/client-server-api/#mroommember) event. */
    reason?: string | undefined;
    /** The fully qualified user ID of the user being banned. */
    user_id: string;
}

export interface Body30 {
    /** The invitee's third party identifier. */
    address: string;
    /** An access token previously registered with the identity server. Servers
can treat this as optional to distinguish between r0.5-compatible clients
and this specification version. */
    id_access_token: string;
    /** The hostname+port of the identity server which should be used for third party identifier lookups. */
    id_server: string;
    /** The kind of address being passed in the address field, for example `email`. */
    medium: string;
}

export interface Body31 {
    /** Optional reason to be included as the `reason` on the subsequent
membership event. */
    reason?: string | undefined;
    /** The fully qualified user ID of the invitee. */
    user_id: string;
}

export interface Body32 {
    /** Optional reason to be included as the `reason` on the subsequent
membership event. */
    reason?: string | undefined;
    /** If supplied, the homeserver must verify that it matches a pending
`m.room.third_party_invite` event in the room, and perform
key validity checking if required by the event. */
    third_party_signed?: Third_party_signed2 | undefined;
}

export interface Body33 {
    /** The reason the user has been kicked. This will be supplied as the
`reason` on the target's updated [`m.room.member`](https://spec.matrix.org/v1.5/client-server-api/#mroommember) event. */
    reason?: string | undefined;
    /** The fully qualified user ID of the user being kicked. */
    user_id: string;
}

export interface Body34 {
    /** Optional reason to be included as the `reason` on the subsequent
membership event. */
    reason?: string | undefined;
}

/** The kind of membership to filter for. Defaults to no filtering if unspecified. When specified alongside `not_membership`, the two parameters create an 'or' condition: either the membership *is* the same as `membership` **or** *is not* the same as `not_membership`. */
export enum Membership {
    Join = "join",
    Invite = "invite",
    Knock = "knock",
    Leave = "leave",
    Ban = "ban",
}

/** The kind of membership to exclude from the results. Defaults to no filtering if unspecified. */
export enum Not_membership {
    Join = "join",
    Invite = "invite",
    Knock = "knock",
    Leave = "leave",
    Ban = "ban",
}

/** The direction to return events from. If this is set to `f`, events will be returned in chronological order starting at `from`. If it is set to `b`, events will be returned in *reverse* chronological order, again starting at `from`. */
export enum Dir4 {
    B = "b",
    F = "f",
}

export interface Body35 {
    /** The event ID the read marker should be located at. The
event MUST belong to the room. */
    "m.fully_read"?: string | undefined;
    /** The event ID to set the read receipt location at. This is
equivalent to calling `/receipt/m.read/$elsewhere:example.org`
and is provided here to save that extra call. */
    "m.read"?: string | undefined;
    /** The event ID to set the *private* read receipt location at. This
equivalent to calling `/receipt/m.read.private/$elsewhere:example.org`
and is provided here to save that extra call. */
    "m.read.private"?: string | undefined;
}

/** The type of receipt to send. This can also be `m.fully_read` as an alternative to [`/read_makers`](https://spec.matrix.org/v1.5/client-server-api/#post_matrixclientv3roomsroomidread_markers). Note that `m.fully_read` does not appear under `m.receipt`: this endpoint effectively calls `/read_markers` internally when presented with a receipt type of `m.fully_read`. */
export enum ReceiptType {
    M_read = "m.read",
    M_read_private = "m.read.private",
    M_fully_read = "m.fully_read",
}

export interface Receipt {
    /** The root thread event's ID (or `main`) for which
thread this receipt is intended to be under. If
not specified, the read receipt is *unthreaded*
(default). */
    thread_id?: string | undefined;
}

export interface Body36 {
    /** The reason for the event being redacted. */
    reason?: string | undefined;
}

export interface Body37 {
    /** The reason the content is being reported. May be blank. */
    reason?: string | undefined;
    /** The score to rate this content as where -100 is most offensive
and 0 is inoffensive. */
    score?: number | undefined;
}

export interface TypingState {
    /** The length of time in milliseconds to mark this user as typing. */
    timeout?: number | undefined;
    /** Whether the user is typing or not. If `false`, the `timeout`
key can be omitted. */
    typing: boolean;
}

export interface Body38 {
    /** Optional reason to be included as the `reason` on the subsequent
membership event. */
    reason?: string | undefined;
    /** The fully qualified user ID of the user being unbanned. */
    user_id: string;
}

export interface Body39 {
    /** The new version for the room. */
    new_version: string;
}

export interface Body40 {
    /** Describes which categories to search in and their criteria. */
    search_categories: Search_categories;
}

export interface Body41 {
    /** The messages to send. A map from user ID, to a map from
device ID to message body. The device ID may also be `*`,
meaning all known devices for the user. */
    messages: { [key: string]: { [key: string]: any; }; };
}

/** Controls whether the client is automatically marked as online by polling this API. If this parameter is omitted then the client is automatically marked as online when it uses this API. Otherwise if the parameter is set to "offline" then the client is not marked as being online when it uses this API. When set to "unavailable", the client is marked as being idle. */
export enum Set_presence {
    Offline = "offline",
    Online = "online",
    Unavailable = "unavailable",
}

export interface Filter3 {
    /** The user account data that isn't associated with rooms to include. */
    account_data?: Account_data4 | undefined;
    /** List of event fields to include. If this list is absent then all fields are included. The entries may include '.' characters to indicate sub-fields. So ['content.body'] will include the 'body' field of the 'content' object. A literal '.' character in a field name may be escaped using a '\\'. A server may include more fields than were requested. */
    event_fields?: string[] | undefined;
    /** The format to use for events. 'client' will return the events in a format suitable for clients. 'federation' will return the raw event as received over federation. The default is 'client'. */
    event_format?: Filter3Event_format | undefined;
    /** The presence updates to include. */
    presence?: Presence4 | undefined;
    /** Filters to be applied to room data. */
    room?: Room | undefined;
}

export interface Filter extends Filter3 {
}

export interface Body42 {
    /** A number in a range `[0,1]` describing a relative
position of the room under the given tag. */
    order?: number | undefined;

    [key: string]: any;
}

export interface Body43 {
    /** The maximum number of results to return. Defaults to 10. */
    limit?: number | undefined;
    /** The term to search for */
    search_term: string;
}

/** The desired resizing method. See the [Thumbnails](https://spec.matrix.org/v1.5/client-server-api/#thumbnails) section for more information. */
export enum Method {
    Crop = "crop",
    Scale = "scale",
}

/** Used by clients to determine the homeserver, identity server, and other optional components they should be interacting with. */
export interface Anonymous {
    /** Used by clients to discover homeserver information. */
    "m.homeserver": MHomeserver;
    /** Used by clients to discover identity server information. */
    "m.identity_server"?: MIdentity_server | undefined;

    [key: string]: any;
}

export interface Anonymous2 {
    /** True if the token is still valid, false otherwise. This should
additionally be false if the token is not a recognised token by
the server. */
    valid: boolean;
}

/** A Matrix-level Error */
export interface ErrorDto {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Anonymous3 {
    /** A token to supply to `from` to keep paginating the responses. Not present when there are
no further results. */
    next_batch?: string | undefined;
    /** The rooms for the current page, with the current filters. */
    rooms: Rooms[];
}

/** A Matrix-level Error */
export interface Error {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error2 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError2 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Anonymous4 {
    /** The child events of the requested event, ordered topologically most-recent first. */
    chunk: Chunk[];
    /** An opaque string representing a pagination token. The absence of this token
means there are no more results to fetch and the client should stop paginating. */
    next_batch?: string | undefined;
    /** An opaque string representing a pagination token. The absence of this token
means this is the start of the result set, i.e. this is the first batch/page. */
    prev_batch?: string | undefined;
}

/** A Matrix-level Error */
export interface Error3 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

export interface Anonymous5 {
    /** The child events of the requested event, ordered topologically
most-recent first. The events returned will match the `relType`
supplied in the URL. */
    chunk: Chunk2[];
    /** An opaque string representing a pagination token. The absence of this token
means there are no more results to fetch and the client should stop paginating. */
    next_batch?: string | undefined;
    /** An opaque string representing a pagination token. The absence of this token
means this is the start of the result set, i.e. this is the first batch/page. */
    prev_batch?: string | undefined;
}

/** A Matrix-level Error */
export interface Error4 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

export interface Anonymous6 {
    /** The child events of the requested event, ordered topologically most-recent
first. The events returned will match the `relType` and `eventType` supplied
in the URL. */
    chunk: Chunk3[];
    /** An opaque string representing a pagination token. The absence of this token
means there are no more results to fetch and the client should stop paginating. */
    next_batch?: string | undefined;
    /** An opaque string representing a pagination token. The absence of this token
means this is the start of the result set, i.e. this is the first batch/page. */
    prev_batch?: string | undefined;
}

/** A Matrix-level Error */
export interface Error5 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

export interface Anonymous7 {
    /** The thread roots, ordered by the `latest_event` in each event's aggregation bundle. All events
returned include bundled [aggregations](https://spec.matrix.org/v1.5/client-server-api/#aggregations).

If the thread root event was sent by an [ignored user](https://spec.matrix.org/v1.5/client-server-api/#ignoring-users), the
event is returned redacted to the caller. This is to simulate the same behaviour of a client doing
aggregation locally on the thread. */
    chunk: Chunk4[];
    /** A token to supply to `from` to keep paginating the responses. Not present when there are
no further results. */
    next_batch?: string | undefined;
}

/** A Matrix-level Error */
export interface Error6 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error7 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError3 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Anonymous8 {
    threepids?: Threepids[] | undefined;
}

export interface Anonymous9 {
    /** An optional field containing a URL where the client must
submit the validation token to, with identical parameters
to the Identity Service API's `POST
/validate/email/submitToken` endpoint (without the requirement
for an access token). The homeserver must send this token to the
user (if applicable), who should then be prompted to provide it
to the client.

If this field is not present, the client can assume that
verification will happen without the client's involvement
provided the homeserver advertises this specification version
in the `/versions` response (ie: r0.5.0). */
    submit_url?: string | undefined;
}

/** A Matrix-level Error */
export interface Error8 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** Used by servers to indicate that additional authentication information is required, */
export interface Anonymous10 {
    /** A list of the stages the client has completed successfully */
    completed?: string[] | undefined;
    /** A list of the login flows supported by the server for this API. */
    flows: Flows[];
    /** Contains any information that the client will need to know in order to
use a given type of authentication. For each login type presented,
that type may be present as a key in this dictionary. For example, the
public part of an OAuth client ID could be given here. */
    params?: { [key: string]: any; } | undefined;
    /** This is a session identifier that the client must pass back to the home
server, if one is provided, in subsequent attempts to authenticate in the
same API call. */
    session?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError4 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError5 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Anonymous11 {
    /** An indicator as to whether or not the homeserver was able to unbind
the 3PID from the identity server. `success` indicates that the
identity server has unbound the identifier whereas `no-support`
indicates that the identity server refuses to support the request
or the homeserver was not able to determine an identity server to
unbind from. */
    id_server_unbind_result: Id_server_unbind_result;
}

export interface RequestTokenResponse {
    /** The session ID. Session IDs are opaque strings that must consist entirely
of the characters `[0-9a-zA-Z.=_-]`. Their length must not exceed 255
characters and they must not be empty. */
    sid: string;
    /** An optional field containing a URL where the client must submit the
validation token to, with identical parameters to the Identity Service
API's `POST /validate/email/submitToken` endpoint (without the requirement
for an access token). The homeserver must send this token to the user (if
applicable), who should then be prompted to provide it to the client.

If this field is not present, the client can assume that verification
will happen without the client's involvement provided the homeserver
advertises this specification version in the `/versions` response
(ie: r0.5.0). */
    submit_url?: string | undefined;
}

/** A Matrix-level Error */
export interface Error9 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error10 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

export interface RequestTokenResponse2 {
    /** The session ID. Session IDs are opaque strings that must consist entirely
of the characters `[0-9a-zA-Z.=_-]`. Their length must not exceed 255
characters and they must not be empty. */
    sid: string;
    /** An optional field containing a URL where the client must submit the
validation token to, with identical parameters to the Identity Service
API's `POST /validate/email/submitToken` endpoint (without the requirement
for an access token). The homeserver must send this token to the user (if
applicable), who should then be prompted to provide it to the client.

If this field is not present, the client can assume that verification
will happen without the client's involvement provided the homeserver
advertises this specification version in the `/versions` response
(ie: r0.5.0). */
    submit_url?: string | undefined;
}

/** A Matrix-level Error */
export interface Error11 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error12 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

export interface Anonymous12 {
    /** An indicator as to whether or not the identity server was able to unbind
the 3PID. `success` indicates that the identity server has unbound the
identifier whereas `no-support` indicates that the identity server
refuses to support the request or the homeserver was not able to determine
an identity server to unbind from. */
    id_server_unbind_result: Id_server_unbind_result2;
}

export interface Anonymous13 {
    /** An indicator as to whether or not the homeserver was able to unbind
the user's 3PIDs from the identity server(s). `success` indicates
that all identifiers have been unbound from the identity server while
`no-support` indicates that one or more identifiers failed to unbind
due to the identity server refusing the request or the homeserver
being unable to determine an identity server to unbind from. This
must be `success` if the homeserver has no identifiers to unbind
for the user. */
    id_server_unbind_result: Id_server_unbind_result3;
}

/** Used by servers to indicate that additional authentication information is required, */
export interface Anonymous14 {
    /** A list of the stages the client has completed successfully */
    completed?: string[] | undefined;
    /** A list of the login flows supported by the server for this API. */
    flows: Flows2[];
    /** Contains any information that the client will need to know in order to
use a given type of authentication. For each login type presented,
that type may be present as a key in this dictionary. For example, the
public part of an OAuth client ID could be given here. */
    params?: { [key: string]: any; } | undefined;
    /** This is a session identifier that the client must pass back to the home
server, if one is provided, in subsequent attempts to authenticate in the
same API call. */
    session?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError6 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

/** Used by servers to indicate that additional authentication information is required, */
export interface Anonymous15 {
    /** A list of the stages the client has completed successfully */
    completed?: string[] | undefined;
    /** A list of the login flows supported by the server for this API. */
    flows: Flows3[];
    /** Contains any information that the client will need to know in order to
use a given type of authentication. For each login type presented,
that type may be present as a key in this dictionary. For example, the
public part of an OAuth client ID could be given here. */
    params?: { [key: string]: any; } | undefined;
    /** This is a session identifier that the client must pass back to the home
server, if one is provided, in subsequent attempts to authenticate in the
same API call. */
    session?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError7 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface RequestTokenResponse3 {
    /** The session ID. Session IDs are opaque strings that must consist entirely
of the characters `[0-9a-zA-Z.=_-]`. Their length must not exceed 255
characters and they must not be empty. */
    sid: string;
    /** An optional field containing a URL where the client must submit the
validation token to, with identical parameters to the Identity Service
API's `POST /validate/email/submitToken` endpoint (without the requirement
for an access token). The homeserver must send this token to the user (if
applicable), who should then be prompted to provide it to the client.

If this field is not present, the client can assume that verification
will happen without the client's involvement provided the homeserver
advertises this specification version in the `/versions` response
(ie: r0.5.0). */
    submit_url?: string | undefined;
}

/** A Matrix-level Error */
export interface Error13 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error14 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

export interface RequestTokenResponse4 {
    /** The session ID. Session IDs are opaque strings that must consist entirely
of the characters `[0-9a-zA-Z.=_-]`. Their length must not exceed 255
characters and they must not be empty. */
    sid: string;
    /** An optional field containing a URL where the client must submit the
validation token to, with identical parameters to the Identity Service
API's `POST /validate/email/submitToken` endpoint (without the requirement
for an access token). The homeserver must send this token to the user (if
applicable), who should then be prompted to provide it to the client.

If this field is not present, the client can assume that verification
will happen without the client's involvement provided the homeserver
advertises this specification version in the `/versions` response
(ie: r0.5.0). */
    submit_url?: string | undefined;
}

/** A Matrix-level Error */
export interface Error15 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error16 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

export interface Anonymous16 {
    /** Device ID associated with the access token. If no device
is associated with the access token (such as in the case
of application services) then this field can be omitted.
Otherwise this is required. */
    device_id?: string | undefined;
    /** When `true`, the user is a [Guest User](#guest-access). When
not present or `false`, the user is presumed to be a non-guest
user. */
    is_guest?: boolean | undefined;
    /** The user ID that owns the access token. */
    user_id: string;
}

/** A Matrix-level Error */
export interface Error17 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error18 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError8 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Anonymous17 {
    /** Each key is an identifier for one of the user's devices. */
    devices?: { [key: string]: DeviceInfo; } | undefined;
    /** The Matrix user ID of the user. */
    user_id?: string | undefined;
}

export interface Anonymous18 {
    /** The custom capabilities the server supports, using the
Java package naming convention. */
    capabilities: Capabilities;
}

/** The rate limit was reached for this request */
export interface RateLimitError9 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

/** Information about the newly created room. */
export interface Anonymous19 {
    /** The created room's ID. */
    room_id: string;
}

/** A Matrix-level Error */
export interface Error19 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** Used by servers to indicate that additional authentication information is required, */
export interface Anonymous20 {
    /** A list of the stages the client has completed successfully */
    completed?: string[] | undefined;
    /** A list of the login flows supported by the server for this API. */
    flows: Flows4[];
    /** Contains any information that the client will need to know in order to
use a given type of authentication. For each login type presented,
that type may be present as a key in this dictionary. For example, the
public part of an OAuth client ID could be given here. */
    params?: { [key: string]: any; } | undefined;
    /** This is a session identifier that the client must pass back to the home
server, if one is provided, in subsequent attempts to authenticate in the
same API call. */
    session?: string | undefined;
}

export interface Anonymous21 {
    /** A list of all registered devices for this user. */
    devices?: Devices[] | undefined;
}

/** Used by servers to indicate that additional authentication information is required, */
export interface Anonymous22 {
    /** A list of the stages the client has completed successfully */
    completed?: string[] | undefined;
    /** A list of the login flows supported by the server for this API. */
    flows: Flows5[];
    /** Contains any information that the client will need to know in order to
use a given type of authentication. For each login type presented,
that type may be present as a key in this dictionary. For example, the
public part of an OAuth client ID could be given here. */
    params?: { [key: string]: any; } | undefined;
    /** This is a session identifier that the client must pass back to the home
server, if one is provided, in subsequent attempts to authenticate in the
same API call. */
    session?: string | undefined;
}

/** A client device */
export interface Device {
    /** Identifier of this device. */
    device_id: string;
    /** Display name set by the user for this device. Absent if no name has been
set. */
    display_name?: string | undefined;
    /** The IP address where this device was last seen. (May be a few minutes out
of date, for efficiency reasons). */
    last_seen_ip?: string | undefined;
    /** The timestamp (in milliseconds since the unix epoch) when this devices
was last seen. (May be a few minutes out of date, for efficiency
reasons). */
    last_seen_ts?: number | undefined;
}

export interface Anonymous23 extends Device {
}

export interface Anonymous24 {
    /** The visibility of the room in the directory. */
    visibility?: Visibility | undefined;
}

/** A Matrix-level Error */
export interface Error20 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error21 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error22 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

export interface Anonymous25 {
    /** The room ID for this room alias. */
    room_id?: string | undefined;
    /** A list of servers that are aware of this room alias. */
    servers?: string[] | undefined;
}

/** A Matrix-level Error */
export interface Error23 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error24 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error25 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error26 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

export interface Anonymous26 {
    /** An array of events. */
    chunk?: Chunk5[] | undefined;
    /** A token which correlates to the end of `chunk`. This
token should be used in the next request to `/events`. */
    end?: string | undefined;
    /** A token which correlates to the start of `chunk`. This
is usually the same token supplied to `from=`. */
    start?: string | undefined;
}

export interface Anonymous27 {
    /** An array of events. */
    chunk?: Chunk6[] | undefined;
    /** A token which correlates to the last value in `chunk`. This
token should be used in the next request to `/events`. */
    end?: string | undefined;
    /** A token which correlates to the first value in `chunk`. This
is usually the same token supplied to `from=`. */
    start?: string | undefined;
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface ClientEventWithoutRoomID {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned6 | undefined;
}

/** The format used for events when they are returned from a homeserver to a client via the Client-Server API, or sent to an Application Service via the Application Services API. */
export interface ClientEvent extends ClientEventWithoutRoomID {
    /** The ID of the room associated with this event. */
    room_id: string;
    unsigned?: Unsigned | undefined;
}

export interface Anonymous28 {
    /** The global private data created by this user. */
    account_data?: Account_data[] | undefined;
    /** A token which correlates to the end of the timelines returned. This
token should be used with the `/events` endpoint to listen for new
events. */
    end: string;
    /** A list of presence events. */
    presence: Presence[];
    rooms: Rooms2[];
}

export interface Anonymous29 {
    /** The joined room ID. */
    room_id: string;
}

/** A Matrix-level Error */
export interface Error27 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError10 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Anonymous30 {
    /** The ID of each room in which the user has `joined` membership. */
    joined_rooms: string[];
}

export interface Anonymous31 {
    /** The Matrix User IDs of all users who updated their device
identity keys. */
    changed?: string[] | undefined;
    /** The Matrix User IDs of all users who may have left all
the end-to-end encrypted rooms they previously shared
with the user. */
    left?: string[] | undefined;
}

export interface Anonymous32 {
    /** If any remote homeservers could not be reached, they are
recorded here. The names of the properties are the names of
the unreachable servers.

If the homeserver could be reached, but the user or device
was unknown, no failure is recorded. Instead, the corresponding
user or device is missing from the `one_time_keys` result. */
    failures?: { [key: string]: any; } | undefined;
    /** One-time keys for the queried devices. A map from user ID, to a
map from devices to a map from `<algorithm>:<key_id>` to the key object.

See the [key algorithms](https://spec.matrix.org/v1.5/client-server-api/#key-algorithms) section for information
on the Key Object format.

If necessary, the claimed key might be a fallback key. Fallback
keys are re-used by the server until replaced by the device. */
    one_time_keys: { [key: string]: { [key: string]: any; }; };
}

export interface Anonymous33 {
    /** Information on the queried devices. A map from user ID, to a
map from device ID to device information.  For each device,
the information returned will be the same as uploaded via
`/keys/upload`, with the addition of an `unsigned`
property. */
    device_keys?: { [key: string]: { [key: string]: DeviceInformation; }; } | undefined;
    /** If any remote homeservers could not be reached, they are
recorded here. The names of the properties are the names of
the unreachable servers.

If the homeserver could be reached, but the user or device
was unknown, no failure is recorded. Instead, the corresponding
user or device is missing from the `device_keys` result. */
    failures?: { [key: string]: any; } | undefined;
    /** Information on the master cross-signing keys of the queried users.
A map from user ID, to master key information.  For each key, the
information returned will be the same as uploaded via
`/keys/device_signing/upload`, along with the signatures
uploaded via `/keys/signatures/upload` that the requesting user
is allowed to see. */
    master_keys?: { [key: string]: Anonymous87; } | undefined;
    /** Information on the self-signing keys of the queried users. A map
from user ID, to self-signing key information.  For each key, the
information returned will be the same as uploaded via
`/keys/device_signing/upload`. */
    self_signing_keys?: { [key: string]: Anonymous88; } | undefined;
    /** Information on the user-signing key of the user making the
request, if they queried their own device information. A map
from user ID, to user-signing key information.  The
information returned will be the same as uploaded via
`/keys/device_signing/upload`. */
    user_signing_keys?: { [key: string]: Anonymous89; } | undefined;
}

export interface Anonymous34 {
    /** A map from user ID to key ID to an error for any signatures
that failed.  If a signature was invalid, the `errcode` will
be set to `M_INVALID_SIGNATURE`. */
    failures?: { [key: string]: { [key: string]: any; }; } | undefined;
}

export interface Anonymous35 {
    /** For each key algorithm, the number of unclaimed one-time keys
of that type currently held on the server for this device.
If an algorithm is not listed, the count for that algorithm
is to be assumed zero. */
    one_time_key_counts: { [key: string]: number; };
}

export interface Anonymous36 {
    /** The knocked room ID. */
    room_id: string;
}

/** A Matrix-level Error */
export interface Error28 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error29 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError11 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Anonymous37 {
    /** The homeserver's supported login types */
    flows?: Flows6[] | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError12 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Anonymous38 {
    /** An access token for the account.
This access token can then be used to authorize other requests. */
    access_token: string;
    /** ID of the logged-in device. Will be the same as the
corresponding parameter in the request, if one was specified. */
    device_id: string;
    /** The lifetime of the access token, in milliseconds. Once
the access token has expired a new access token can be
obtained by using the provided refresh token. If no
refresh token is provided, the client will need to re-log in
to obtain a new access token. If not given, the client can
assume that the access token will not expire. */
    expires_in_ms?: number | undefined;
    /** The server_name of the homeserver on which the account has
been registered.

**Deprecated**. Clients should extract the server_name from
`user_id` (by splitting at the first colon) if they require
it. Note also that `homeserver` is not spelt this way. */
    home_server?: string | undefined;
    /** A refresh token for the account. This token can be used to
obtain a new access token when it expires by calling the
`/refresh` endpoint. */
    refresh_token?: string | undefined;
    /** The fully-qualified Matrix ID for the account. */
    user_id: string;
    /** Optional client configuration provided by the server. If present,
clients SHOULD use the provided object to reconfigure themselves,
optionally validating the URLs within. This object takes the same
form as the one returned from .well-known autodiscovery. */
    well_known?: Well_known | undefined;
}

/** A Matrix-level Error */
export interface Error30 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error31 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError13 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Anonymous39 {
    /** The token to supply in the `from` param of the next
`/notifications` request in order to request more
events. If this is absent, there are no more results. */
    next_token?: string | undefined;
    /** The list of events that triggered notifications. */
    notifications: Notifications[];
}

export interface Anonymous40 {
    /** Whether the user is currently active */
    currently_active?: boolean | undefined;
    /** The length of time in milliseconds since an action was performed
by this user. */
    last_active_ago?: number | undefined;
    /** This user's presence. */
    presence: Presence2;
    /** The state message for this user if one was set. */
    status_msg?: string | undefined;
}

/** A Matrix-level Error */
export interface Error32 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error33 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError14 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Anonymous41 {
    /** The user's avatar URL if they have set one, otherwise not present. */
    avatar_url?: string | undefined;
    /** The user's display name if they have set one, otherwise not present. */
    displayname?: string | undefined;
}

/** A Matrix-level Error */
export interface Error34 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error35 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

export interface Anonymous42 {
    /** The user's avatar URL if they have set one, otherwise not present. */
    avatar_url?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError15 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Anonymous43 {
    /** The user's display name if they have set one, otherwise not present. */
    displayname?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError16 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

/** A list of the rooms on the server. */
export interface Anonymous44 {
    /** A paginated chunk of public rooms. */
    chunk: Chunk7[];
    /** A pagination token for the response. The absence of this token
means there are no more results to fetch and the client should
stop paginating. */
    next_batch?: string | undefined;
    /** A pagination token that allows fetching previous results. The
absence of this token means there are no results before this
batch, i.e. this is the first batch. */
    prev_batch?: string | undefined;
    /** An estimate on the total number of public rooms, if the
server has an estimate. */
    total_room_count_estimate?: number | undefined;
}

/** A list of the rooms on the server. */
export interface Anonymous45 {
    /** A paginated chunk of public rooms. */
    chunk: Chunk8[];
    /** A pagination token for the response. The absence of this token
means there are no more results to fetch and the client should
stop paginating. */
    next_batch?: string | undefined;
    /** A pagination token that allows fetching previous results. The
absence of this token means there are no results before this
batch, i.e. this is the first batch. */
    prev_batch?: string | undefined;
    /** An estimate on the total number of public rooms, if the
server has an estimate. */
    total_room_count_estimate?: number | undefined;
}

export interface Anonymous46 {
    /** An array containing the current pushers for the user */
    pushers?: Pushers[] | undefined;
}

/** A Matrix-level Error */
export interface Error36 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError17 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Anonymous47 {
    /** The global ruleset. */
    global: Global;
}

/** A Matrix-level Error */
export interface Error37 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

export interface PushRule {
    /** The actions to perform when this rule is matched. */
    actions: any[];
    /** The conditions that must hold true for an event in order for a rule to be
applied to an event. A rule with no conditions always matches. Only
applicable to `underride` and `override` rules. */
    conditions?: Conditions2[] | undefined;
    /** Whether this is a default rule, or has been set explicitly. */
    default: boolean;
    /** Whether the push rule is enabled or not. */
    enabled: boolean;
    /** The glob-style pattern to match against.  Only applicable to `content`
rules. */
    pattern?: string | undefined;
    /** The ID of this rule. */
    rule_id: string;
}

/** The push rule. */
export interface Anonymous48 extends PushRule {
}

/** A Matrix-level Error */
export interface Error38 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error39 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error40 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError18 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Anonymous49 {
    /** The action(s) to perform for this rule. */
    actions: any[];
}

/** A Matrix-level Error */
export interface Error41 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error42 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

export interface Anonymous50 {
    /** Whether the push rule is enabled or not. */
    enabled: boolean;
}

/** A Matrix-level Error */
export interface Error43 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error44 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

export interface Anonymous51 {
    /** The new access token to use. */
    access_token: string;
    /** The lifetime of the access token, in milliseconds. If not
given, the client can assume that the access token will not
expire. */
    expires_in_ms?: number | undefined;
    /** The new refresh token to use when the access token needs to
be refreshed again. If not given, the old refresh token can
be re-used. */
    refresh_token?: string | undefined;
}

/** A Matrix-level Error */
export interface Error45 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError19 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Anonymous52 {
    /** An access token for the account.
This access token can then be used to authorize other requests.
Required if the `inhibit_login` option is false. */
    access_token?: string | undefined;
    /** ID of the registered device. Will be the same as the
corresponding parameter in the request, if one was specified.
Required if the `inhibit_login` option is false. */
    device_id?: string | undefined;
    /** The lifetime of the access token, in milliseconds. Once
the access token has expired a new access token can be
obtained by using the provided refresh token. If no
refresh token is provided, the client will need to re-log in
to obtain a new access token. If not given, the client can
assume that the access token will not expire.

Omitted if the `inhibit_login` option is true. */
    expires_in_ms?: number | undefined;
    /** The server_name of the homeserver on which the account has
been registered.

**Deprecated**. Clients should extract the server_name from
`user_id` (by splitting at the first colon) if they require
it. Note also that `homeserver` is not spelt this way. */
    home_server?: string | undefined;
    /** A refresh token for the account. This token can be used to
obtain a new access token when it expires by calling the
`/refresh` endpoint.

Omitted if the `inhibit_login` option is true. */
    refresh_token?: string | undefined;
    /** The fully-qualified Matrix user ID (MXID) that has been registered.

Any user ID returned by this API must conform to the grammar given in the
[Matrix specification](https://spec.matrix.org/v1.5/appendices/#user-identifiers). */
    user_id: string;
}

/** A Matrix-level Error */
export interface Error46 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** Used by servers to indicate that additional authentication information is required, */
export interface Anonymous53 {
    /** A list of the stages the client has completed successfully */
    completed?: string[] | undefined;
    /** A list of the login flows supported by the server for this API. */
    flows: Flows7[];
    /** Contains any information that the client will need to know in order to
use a given type of authentication. For each login type presented,
that type may be present as a key in this dictionary. For example, the
public part of an OAuth client ID could be given here. */
    params?: { [key: string]: any; } | undefined;
    /** This is a session identifier that the client must pass back to the home
server, if one is provided, in subsequent attempts to authenticate in the
same API call. */
    session?: string | undefined;
}

/** A Matrix-level Error */
export interface Error47 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError20 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Anonymous54 {
    /** A flag to indicate that the username is available. This should always
be `true` when the server replies with 200 OK. */
    available?: boolean | undefined;
}

/** A Matrix-level Error */
export interface Error48 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError21 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface RequestTokenResponse5 {
    /** The session ID. Session IDs are opaque strings that must consist entirely
of the characters `[0-9a-zA-Z.=_-]`. Their length must not exceed 255
characters and they must not be empty. */
    sid: string;
    /** An optional field containing a URL where the client must submit the
validation token to, with identical parameters to the Identity Service
API's `POST /validate/email/submitToken` endpoint (without the requirement
for an access token). The homeserver must send this token to the user (if
applicable), who should then be prompted to provide it to the client.

If this field is not present, the client can assume that verification
will happen without the client's involvement provided the homeserver
advertises this specification version in the `/versions` response
(ie: r0.5.0). */
    submit_url?: string | undefined;
}

/** A Matrix-level Error */
export interface Error49 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error50 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

export interface RequestTokenResponse6 {
    /** The session ID. Session IDs are opaque strings that must consist entirely
of the characters `[0-9a-zA-Z.=_-]`. Their length must not exceed 255
characters and they must not be empty. */
    sid: string;
    /** An optional field containing a URL where the client must submit the
validation token to, with identical parameters to the Identity Service
API's `POST /validate/email/submitToken` endpoint (without the requirement
for an access token). The homeserver must send this token to the user (if
applicable), who should then be prompted to provide it to the client.

If this field is not present, the client can assume that verification
will happen without the client's involvement provided the homeserver
advertises this specification version in the `/versions` response
(ie: r0.5.0). */
    submit_url?: string | undefined;
}

/** A Matrix-level Error */
export interface Error51 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error52 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

export interface RoomKeysUpdateResponse {
    /** The number of keys stored in the backup */
    count: number;
    /** The new etag value representing stored keys in the backup.
See `GET /room_keys/version/{version}` for more details. */
    etag: string;
}

/** A Matrix-level Error */
export interface Error53 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError22 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Anonymous55 {
    /** A map of room IDs to room key backup data. */
    rooms: { [key: string]: Anonymous90; };
}

/** A Matrix-level Error */
export interface Error54 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError23 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface RoomKeysUpdateResponse2 {
    /** The number of keys stored in the backup */
    count: number;
    /** The new etag value representing stored keys in the backup.
See `GET /room_keys/version/{version}` for more details. */
    etag: string;
}

/** A Matrix-level Error */
export interface Error55 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error56 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError24 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface RoomKeysUpdateResponse3 {
    /** The number of keys stored in the backup */
    count: number;
    /** The new etag value representing stored keys in the backup.
See `GET /room_keys/version/{version}` for more details. */
    etag: string;
}

/** A Matrix-level Error */
export interface Error57 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError25 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

/** The backed up keys for a room. */
export interface RoomKeyBackup2 {
    /** A map of session IDs to key data. */
    sessions: { [key: string]: Anonymous91; };
}

/** A Matrix-level Error */
export interface Error58 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError26 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface RoomKeysUpdateResponse4 {
    /** The number of keys stored in the backup */
    count: number;
    /** The new etag value representing stored keys in the backup.
See `GET /room_keys/version/{version}` for more details. */
    etag: string;
}

/** A Matrix-level Error */
export interface Error59 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error60 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError27 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface RoomKeysUpdateResponse5 {
    /** The number of keys stored in the backup */
    count: number;
    /** The new etag value representing stored keys in the backup.
See `GET /room_keys/version/{version}` for more details. */
    etag: string;
}

/** A Matrix-level Error */
export interface Error61 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError28 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

/** The key data */
export interface KeyBackupData2 {
    /** The index of the first message in the session that the key can decrypt. */
    first_message_index: number;
    /** The number of times this key has been forwarded via key-sharing between devices. */
    forwarded_count: number;
    /** Whether the device backing up the key verified the device that the key
is from. */
    is_verified: boolean;
    /** Algorithm-dependent data.  See the documentation for the backup
algorithms in [Server-side key backups](https://spec.matrix.org/v1.5/client-server-api/#server-side-key-backups) for more information on the
expected format of the data. */
    session_data: any;
}

/** A Matrix-level Error */
export interface Error62 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError29 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface RoomKeysUpdateResponse6 {
    /** The number of keys stored in the backup */
    count: number;
    /** The new etag value representing stored keys in the backup.
See `GET /room_keys/version/{version}` for more details. */
    etag: string;
}

/** A Matrix-level Error */
export interface Error63 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError30 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Anonymous56 {
    /** The algorithm used for storing backups. */
    algorithm: Algorithm;
    /** Algorithm-dependent data. See the documentation for the backup
algorithms in [Server-side key backups](https://spec.matrix.org/v1.5/client-server-api/#server-side-key-backups) for more information on the
expected format of the data. */
    auth_data: any;
    /** The number of keys stored in the backup. */
    count: number;
    /** An opaque string representing stored keys in the backup.
Clients can compare it with the `etag` value they received
in the request of their last key storage request.  If not
equal, another client has modified the backup. */
    etag: string;
    /** The backup version. */
    version: string;
}

/** A Matrix-level Error */
export interface Error64 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError31 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Anonymous57 {
    /** The backup version. This is an opaque string. */
    version: string;
}

/** The rate limit was reached for this request */
export interface RateLimitError32 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

/** A Matrix-level Error */
export interface Error65 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError33 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Anonymous58 {
    /** The algorithm used for storing backups. */
    algorithm: Algorithm2;
    /** Algorithm-dependent data. See the documentation for the backup
algorithms in [Server-side key backups](https://spec.matrix.org/v1.5/client-server-api/#server-side-key-backups) for more information on the
expected format of the data. */
    auth_data: any;
    /** The number of keys stored in the backup. */
    count: number;
    /** An opaque string representing stored keys in the backup.
Clients can compare it with the `etag` value they received
in the request of their last key storage request.  If not
equal, another client has modified the backup. */
    etag: string;
    /** The backup version. */
    version: string;
}

/** A Matrix-level Error */
export interface Error66 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError34 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

/** A Matrix-level Error */
export interface Error67 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error68 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError35 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Anonymous59 {
    /** The server's local aliases on the room. Can be empty. */
    aliases: string[];
}

/** A Matrix-level Error */
export interface Error69 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error70 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError36 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

/** A Matrix-level Error */
export interface Error71 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The events and state surrounding the requested event. */
export interface Anonymous60 {
    /** A token that can be used to paginate forwards with. */
    end?: string | undefined;
    /** Details of the requested event. */
    event?: Event | undefined;
    /** A list of room events that happened just after the
requested event, in chronological order. */
    events_after?: Events_after[] | undefined;
    /** A list of room events that happened just before the
requested event, in reverse-chronological order. */
    events_before?: Events_before[] | undefined;
    /** A token that can be used to paginate backwards with. */
    start?: string | undefined;
    /** The state of the room at the last event returned. */
    state?: State[] | undefined;
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface ClientEventWithoutRoomID2 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned12 | undefined;
}

/** The format used for events when they are returned from a homeserver to a client via the Client-Server API, or sent to an Application Service via the Application Services API. */
export interface ClientEvent2 extends ClientEventWithoutRoomID2 {
    /** The ID of the room associated with this event. */
    room_id: string;
    unsigned?: Unsigned2 | undefined;
}

/** A Matrix-level Error */
export interface Error72 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error73 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError37 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface RoomInfo {
    /** The private data that this user has attached to this room. */
    account_data?: Account_data2[] | undefined;
    /** The user's membership state in this room. */
    membership?: RoomInfoMembership | undefined;
    /** The pagination chunk for this room. */
    messages?: Messages | undefined;
    /** The ID of this room. */
    room_id: string;
    /** If the user is a member of the room this will be the
current state of the room as a list of events. If the
user has left the room this will be the state of the
room when they left it. */
    state?: State2[] | undefined;
    /** Whether this room is visible to the `/publicRooms` API
or not." */
    visibility?: RoomInfoVisibility | undefined;
}

/** A Matrix-level Error */
export interface Error74 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError38 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

/** A Matrix-level Error */
export interface Error75 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error76 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError39 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Anonymous61 {
    /** The joined room ID. */
    room_id: string;
}

/** A Matrix-level Error */
export interface Error77 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError40 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Anonymous62 {
    /** A map from user ID to a RoomMember object. */
    joined?: { [key: string]: RoomMember; } | undefined;
}

/** A Matrix-level Error */
export interface Error78 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError41 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Anonymous63 {
    chunk?: Chunk9[] | undefined;
}

/** A list of messages with a new token to request more. */
export interface Anonymous64 {
    /** A list of room events. The order depends on the `dir` parameter.
For `dir=b` events will be in reverse-chronological order,
for `dir=f` in chronological order. (The exact definition of `chronological`
is dependent on the server implementation.)

Note that an empty `chunk` does not *necessarily* imply that no more events
are available. Clients should continue to paginate until no `end` property
is returned. */
    chunk: Chunk10[];
    /** A token corresponding to the end of `chunk`. This token can be passed
back to this endpoint to request further events.

If no further events are available (either because we have
reached the start of the timeline, or because the user does
not have permission to see any more events), this property
is omitted from the response. */
    end?: string | undefined;
    /** A token corresponding to the start of `chunk`. This will be the same as
the value given in `from`. */
    start: string;
    /** A list of state events relevant to showing the `chunk`. For example, if
`lazy_load_members` is enabled in the filter then this may contain
the membership events for the senders of events in the `chunk`.

Unless `include_redundant_members` is `true`, the server
may remove membership events which would have already been
sent to the client in prior calls to this endpoint, assuming
the membership of those members has not changed. */
    state?: State3[] | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError42 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

/** A Matrix-level Error */
export interface Error79 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError43 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Anonymous65 {
    /** A unique identifier for the event. */
    event_id?: string | undefined;
}

export interface Anonymous66 {
    /** A unique identifier for the event. */
    event_id: string;
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface ClientEventWithoutRoomID3 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned17 | undefined;
}

/** The format used for events when they are returned from a homeserver to a client via the Client-Server API, or sent to an Application Service via the Application Services API. */
export interface ClientEvent3 extends ClientEventWithoutRoomID3 {
    /** The ID of the room associated with this event. */
    room_id: string;
    unsigned?: Unsigned3 | undefined;
}

export interface Anonymous67 {
    /** A unique identifier for the event. */
    event_id: string;
}

/** A Matrix-level Error */
export interface Error80 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error81 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError44 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

/** A Matrix-level Error */
export interface Error82 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

export interface Anonymous68 {
    /** The ID of the new room. */
    replacement_room: string;
}

/** A Matrix-level Error */
export interface Error83 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error84 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

export interface Results {
    /** Describes which categories to search in and their criteria. */
    search_categories: Search_categories2;
}

/** The rate limit was reached for this request */
export interface RateLimitError45 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Anonymous69 {
    /** The global private data created by this user. */
    account_data?: Account_data3 | undefined;
    /** Information on end-to-end device updates, as specified in
[End-to-end encryption](https://spec.matrix.org/v1.5/client-server-api/#e2e-extensions-to-sync). */
    device_lists?: any | undefined;
    /** Information on end-to-end encryption keys, as specified
in [End-to-end encryption](https://spec.matrix.org/v1.5/client-server-api/#e2e-extensions-to-sync). */
    device_one_time_keys_count?: { [key: string]: number; } | undefined;
    /** The batch token to supply in the `since` param of the next
`/sync` request. */
    next_batch: string;
    /** The updates to the presence status of other users. */
    presence?: Presence3 | undefined;
    /** Updates to rooms. */
    rooms?: Rooms3 | undefined;
    /** Information on the send-to-device messages for the client
device, as defined in [Send-to-Device messaging](https://spec.matrix.org/v1.5/client-server-api/#extensions-to-sync). */
    to_device?: any | undefined;
}

export interface Location {
    /** An alias for a matrix room. */
    alias: string;
    /** Information used to identify this third party location. */
    fields: any;
    /** The protocol ID that the third party location is a part of. */
    protocol: string;
}

/** A Matrix-level Error */
export interface Error85 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

export interface Location2 {
    /** An alias for a matrix room. */
    alias: string;
    /** Information used to identify this third party location. */
    fields: any;
    /** The protocol ID that the third party location is a part of. */
    protocol: string;
}

/** A Matrix-level Error */
export interface Error86 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

export interface Protocol {
    /** The type definitions for the fields defined in the `user_fields` and
`location_fields`. Each entry in those arrays MUST have an entry here. The
`string` key for this object is field name itself.

May be an empty object if no fields are defined. */
    field_types: { [key: string]: Anonymous92; };
    /** A content URI representing an icon for the third party protocol. */
    icon: string;
    /** A list of objects representing independent instances of configuration.
For example, multiple networks on IRC if multiple are provided by the
same application service. */
    instances: Instances[];
    /** Fields which may be used to identify a third party location. These should be
ordered to suggest the way that entities may be grouped, where higher
groupings are ordered first. For example, the name of a network should be
searched before the name of a channel. */
    location_fields: string[];
    /** Fields which may be used to identify a third party user. These should be
ordered to suggest the way that entities may be grouped, where higher
groupings are ordered first. For example, the name of a network should be
searched before the nickname of a user. */
    user_fields: string[];
}

/** A Matrix-level Error */
export interface Error87 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

export interface Protocol2 {
    /** The type definitions for the fields defined in the `user_fields` and
`location_fields`. Each entry in those arrays MUST have an entry here. The
`string` key for this object is field name itself.

May be an empty object if no fields are defined. */
    field_types: { [key: string]: Anonymous93; };
    /** A content URI representing an icon for the third party protocol. */
    icon: string;
    /** A list of objects representing independent instances of configuration.
For example, multiple networks on IRC if multiple are provided by the
same application service. */
    instances: Instances2[];
    /** Fields which may be used to identify a third party location. These should be
ordered to suggest the way that entities may be grouped, where higher
groupings are ordered first. For example, the name of a network should be
searched before the name of a channel. */
    location_fields: string[];
    /** Fields which may be used to identify a third party user. These should be
ordered to suggest the way that entities may be grouped, where higher
groupings are ordered first. For example, the name of a network should be
searched before the nickname of a user. */
    user_fields: string[];
}

export interface User {
    /** Information used to identify this third party location. */
    fields: any;
    /** The protocol ID that the third party location is a part of. */
    protocol: string;
    /** A Matrix User ID represting a third party user. */
    userid: string;
}

/** A Matrix-level Error */
export interface Error88 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

export interface User2 {
    /** Information used to identify this third party location. */
    fields: any;
    /** The protocol ID that the third party location is a part of. */
    protocol: string;
    /** A Matrix User ID represting a third party user. */
    userid: string;
}

/** A Matrix-level Error */
export interface Error89 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error90 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error91 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error92 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error93 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error94 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

export interface Anonymous70 {
    /** The ID of the filter that was created. Cannot start
with a `{` as this character is used to determine
if the filter provided is inline JSON or a previously
declared filter by homeservers on some APIs. */
    filter_id: string;
}

export interface Filter4 {
    /** The user account data that isn't associated with rooms to include. */
    account_data?: Account_data6 | undefined;
    /** List of event fields to include. If this list is absent then all fields are included. The entries may include '.' characters to indicate sub-fields. So ['content.body'] will include the 'body' field of the 'content' object. A literal '.' character in a field name may be escaped using a '\\'. A server may include more fields than were requested. */
    event_fields?: string[] | undefined;
    /** The format to use for events. 'client' will return the events in a format suitable for clients. 'federation' will return the raw event as received over federation. The default is 'client'. */
    event_format?: Filter4Event_format | undefined;
    /** The presence updates to include. */
    presence?: Presence5 | undefined;
    /** Filters to be applied to room data. */
    room?: Room2 | undefined;
}

export interface Anonymous71 extends Filter4 {
}

export interface OpenIdCredentials {
    /** An access token the consumer may use to verify the identity of
the person who generated the token. This is given to the federation
API `GET /openid/userinfo` to verify the user's identity. */
    access_token: string;
    /** The number of seconds before this token expires and a new one must
be generated. */
    expires_in: number;
    /** The homeserver domain the consumer should use when attempting to
verify the user's identity. */
    matrix_server_name: string;
    /** The string `Bearer`. */
    token_type: string;
}

/** The rate limit was reached for this request */
export interface RateLimitError46 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

/** A Matrix-level Error */
export interface Error95 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error96 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error97 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error98 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error99 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

export interface Anonymous72 {
    tags?: { [key: string]: Tag; } | undefined;
}

export interface Anonymous73 {
    /** Indicates if the result list has been truncated by the limit. */
    limited: boolean;
    /** Ordered by rank and then whether or not profile info is available. */
    results: Results2[];
}

/** The rate limit was reached for this request */
export interface RateLimitError47 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Anonymous74 {
    /** The password to use. */
    password: string;
    /** The time-to-live in seconds */
    ttl: number;
    /** A list of TURN URIs */
    uris: string[];
    /** The username to use. */
    username: string;
}

/** The rate limit was reached for this request */
export interface RateLimitError48 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Anonymous75 {
    /** Experimental features the server supports. Features not listed here,
or the lack of this property all together, indicate that a feature is
not supported. */
    unstable_features?: { [key: string]: boolean; } | undefined;
    /** The supported versions. */
    versions: string[];
}

export interface Anonymous76 {
    /** The maximum size an upload can be in bytes.
Clients SHOULD use this as a guide when uploading content.
If not listed or null, the size limit should be treated as unknown. */
    "m.upload.size"?: number | undefined;
}

/** A Matrix-level Error */
export interface Error100 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError49 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

/** A Matrix-level Error */
export interface Error101 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError50 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

/** A Matrix-level Error */
export interface Error102 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

export interface Anonymous77 {
    /** The byte-size of the image. Omitted if there is no image attached. */
    "matrix:image:size"?: number | undefined;
    /** An [MXC URI](https://spec.matrix.org/v1.5/client-server-api/#matrix-content-mxc-uris) to the image. Omitted if there is no image. */
    "og:image"?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError51 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

/** A Matrix-level Error */
export interface Error103 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error104 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError52 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

/** A Matrix-level Error */
export interface Error105 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

export interface Anonymous78 {
    /** The [MXC URI](https://spec.matrix.org/v1.5/client-server-api/#matrix-content-mxc-uris) to the uploaded content. */
    content_uri: string;
}

/** A Matrix-level Error */
export interface Error106 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** A Matrix-level Error */
export interface Error107 {
    /** An error code. */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
}

/** The rate limit was reached for this request */
export interface RateLimitError53 {
    /** The M_LIMIT_EXCEEDED error code */
    errcode: string;
    /** A human-readable error message. */
    error?: string | undefined;
    /** The amount of time in milliseconds the client should wait
before trying the request again. */
    retry_after_ms?: number | undefined;
}

export interface Three_pid_creds {
    /** The client secret used in the session with the identity server. */
    client_secret: string;
    /** An access token previously registered with the identity server. Servers
can treat this as optional to distinguish between r0.5-compatible clients
and this specification version. */
    id_access_token: string;
    /** The identity server to use. */
    id_server: string;
    /** The session identifier given by the identity server. */
    sid: string;
}

/** Used by clients to submit authentication information to the interactive-authentication API */
export interface Anonymous94 {
    /** The value of the session key given by the homeserver. */
    session?: string | undefined;
    /** The authentication type that the client is attempting to complete.
May be omitted if `session` is given, and the client is reissuing a
request which it believes has been completed out-of-band (for example,
via the [fallback mechanism](#fallback)). */
    type?: string | undefined;

    [key: string]: any;
}

export interface Auth extends Anonymous94 {
}

export enum Body4Medium {
    Email = "email",
    Msisdn = "msisdn",
}

export enum Body7Medium {
    Email = "email",
    Msisdn = "msisdn",
}

/** Used by clients to submit authentication information to the interactive-authentication API */
export interface Anonymous95 {
    /** The value of the session key given by the homeserver. */
    session?: string | undefined;
    /** The authentication type that the client is attempting to complete.
May be omitted if `session` is given, and the client is reissuing a
request which it believes has been completed out-of-band (for example,
via the [fallback mechanism](#fallback)). */
    type?: string | undefined;

    [key: string]: any;
}

export interface Auth2 extends Anonymous95 {
}

/** Used by clients to submit authentication information to the interactive-authentication API */
export interface Anonymous96 {
    /** The value of the session key given by the homeserver. */
    session?: string | undefined;
    /** The authentication type that the client is attempting to complete.
May be omitted if `session` is given, and the client is reissuing a
request which it believes has been completed out-of-band (for example,
via the [fallback mechanism](#fallback)). */
    type?: string | undefined;

    [key: string]: any;
}

export interface Auth3 extends Anonymous96 {
}

export interface Initial_state {
    /** The content of the event. */
    content: any;
    /** The state_key of the state event. Defaults to an empty string. */
    state_key?: string | undefined;
    /** The type of event to send. */
    type: string;
}

export interface Invite_3pid {
    /** The invitee's third party identifier. */
    address: string;
    /** An access token previously registered with the identity server. Servers
can treat this as optional to distinguish between r0.5-compatible clients
and this specification version. */
    id_access_token: string;
    /** The hostname+port of the identity server which should be used for third party identifier lookups. */
    id_server: string;
    /** The kind of address being passed in the address field, for example `email`. */
    medium: string;
}

export enum Body12Preset {
    Private_chat = "private_chat",
    Public_chat = "public_chat",
    Trusted_private_chat = "trusted_private_chat",
}

export enum Body12Visibility {
    Public = "public",
    Private = "private",
}

/** Used by clients to submit authentication information to the interactive-authentication API */
export interface Anonymous97 {
    /** The value of the session key given by the homeserver. */
    session?: string | undefined;
    /** The authentication type that the client is attempting to complete.
May be omitted if `session` is given, and the client is reissuing a
request which it believes has been completed out-of-band (for example,
via the [fallback mechanism](#fallback)). */
    type?: string | undefined;

    [key: string]: any;
}

export interface Auth4 extends Anonymous97 {
}

/** Used by clients to submit authentication information to the interactive-authentication API */
export interface Anonymous98 {
    /** The value of the session key given by the homeserver. */
    session?: string | undefined;
    /** The authentication type that the client is attempting to complete.
May be omitted if `session` is given, and the client is reissuing a
request which it believes has been completed out-of-band (for example,
via the [fallback mechanism](#fallback)). */
    type?: string | undefined;

    [key: string]: any;
}

export interface Auth5 extends Anonymous98 {
}

export enum Body16Visibility {
    Public = "public",
    Private = "private",
}

export enum Body17Visibility {
    Private = "private",
    Public = "public",
}

/** A signature of an `m.third_party_invite` token to prove that this user owns a third party identity which has been invited to the room. */
export interface Anonymous99 {
    /** The Matrix ID of the invitee. */
    mxid: string;
    /** The Matrix ID of the user who issued the invite. */
    sender: string;
    /** A signatures object containing a signature of the entire signed object. */
    signatures: { [key: string]: { [key: string]: string; }; };
    /** The state key of the m.third_party_invite event. */
    token: string;
}

export interface Third_party_signed extends Anonymous99 {
}

/** Used by clients to submit authentication information to the interactive-authentication API */
export interface Anonymous100 {
    /** The value of the session key given by the homeserver. */
    session?: string | undefined;
    /** The authentication type that the client is attempting to complete.
May be omitted if `session` is given, and the client is reissuing a
request which it believes has been completed out-of-band (for example,
via the [fallback mechanism](#fallback)). */
    type?: string | undefined;

    [key: string]: any;
}

export interface Auth6 extends Anonymous100 {
}

/** Cross signing key */
export interface CrossSigningKey {
    /** The public key.  The object must have exactly one property, whose name is
in the form `<algorithm>:<unpadded_base64_public_key>`, and whose value
is the unpadded base64 public key. */
    keys: { [key: string]: string; };
    /** Signatures of the key, calculated using the process described at [Signing JSON](https://spec.matrix.org/v1.5/appendices/#signing-json).
Optional for the master key. Other keys must be signed by the
user\'s master key. */
    signatures?: any | undefined;
    /** What the key is used for. */
    usage: Usage[];
    /** The ID of the user the key belongs to. */
    user_id: string;
}

export interface Master_key extends CrossSigningKey {
}

/** Cross signing key */
export interface CrossSigningKey2 {
    /** The public key.  The object must have exactly one property, whose name is
in the form `<algorithm>:<unpadded_base64_public_key>`, and whose value
is the unpadded base64 public key. */
    keys: { [key: string]: string; };
    /** Signatures of the key, calculated using the process described at [Signing JSON](https://spec.matrix.org/v1.5/appendices/#signing-json).
Optional for the master key. Other keys must be signed by the
user\'s master key. */
    signatures?: any | undefined;
    /** What the key is used for. */
    usage: Usage2[];
    /** The ID of the user the key belongs to. */
    user_id: string;
}

export interface Self_signing_key extends CrossSigningKey2 {
}

/** Cross signing key */
export interface CrossSigningKey3 {
    /** The public key.  The object must have exactly one property, whose name is
in the form `<algorithm>:<unpadded_base64_public_key>`, and whose value
is the unpadded base64 public key. */
    keys: { [key: string]: string; };
    /** Signatures of the key, calculated using the process described at [Signing JSON](https://spec.matrix.org/v1.5/appendices/#signing-json).
Optional for the master key. Other keys must be signed by the
user\'s master key. */
    signatures?: any | undefined;
    /** What the key is used for. */
    usage: Usage3[];
    /** The ID of the user the key belongs to. */
    user_id: string;
}

export interface User_signing_key extends CrossSigningKey3 {
}

/** Device identity keys */
export interface DeviceKeys {
    /** The encryption algorithms supported by this device. */
    algorithms: string[];
    /** The ID of the device these keys belong to. Must match the device ID used
when logging in. */
    device_id: string;
    /** Public identity keys. The names of the properties should be in the
format `<algorithm>:<device_id>`. The keys themselves should be
encoded as specified by the key algorithm. */
    keys: { [key: string]: string; };
    /** Signatures for the device key object. A map from user ID, to a map from
`<algorithm>:<device_id>` to the signature.

The signature is calculated using the process described at [Signing JSON](https://spec.matrix.org/v1.5/appendices/#signing-json). */
    signatures: { [key: string]: { [key: string]: string; }; };
    /** The ID of the user the device belongs to. Must match the user ID used
when logging in. */
    user_id: string;
}

export interface Device_keys extends DeviceKeys {
}

export interface Identifier {
    /** The type of identification.  See [Identifier types](https://spec.matrix.org/v1.5/client-server-api/#identifier-types) for supported values and additional property descriptions. */
    type: string;

    [key: string]: any;
}

export enum Body21Type {
    M_login_password = "m.login.password",
    M_login_token = "m.login.token",
}

export enum PresenceStatePresence {
    Online = "online",
    Offline = "offline",
    Unavailable = "unavailable",
}

export interface Filter2 {
    /** An optional string to search for in the room metadata, e.g. name,
topic, canonical alias, etc. */
    generic_search_term?: string | undefined;
    /** An optional list of [room types](https://spec.matrix.org/v1.5/client-server-api/#types) to search
for. To include rooms without a room type, specify `null` within this
list. When not specified, all applicable rooms (regardless of type)
are returned. */
    room_types?: string[] | undefined;
}

export interface Data {
    /** The format to send notifications in to Push Gateways if the
`kind` is `http`. The details about what fields the
homeserver should send to the push gateway are defined in the
[Push Gateway Specification](https://spec.matrix.org/v1.5/push-gateway-api/). Currently the only format
available is 'event_id_only'. */
    format?: string | undefined;
    /** Required if `kind` is `http`. The URL to use to send
notifications to. MUST be an HTTPS URL with a path of
`/_matrix/push/v1/notify`. */
    url?: string | undefined;
}

export interface PushCondition {
    /** Required for `room_member_count` conditions. A decimal integer
optionally prefixed by one of, ==, <, >, >= or <=. A prefix of < matches
rooms where the member count is strictly less than the given number and
so forth. If no prefix is present, this parameter defaults to ==. */
    is?: string | undefined;
    /** Required for `event_match` conditions. The dot-separated field of the
event to match.

Required for `sender_notification_permission` conditions. The field in
the power level event the user needs a minimum power level for. Fields
must be specified under the `notifications` property in the power level
event's `content`. */
    key?: string | undefined;
    /** The kind of condition to apply. See [conditions](https://spec.matrix.org/v1.5/client-server-api/#conditions) for
more information on the allowed kinds and how they work. */
    kind: string;
    /** Required for `event_match` conditions. The glob-style pattern to
match against. */
    pattern?: string | undefined;
}

export interface Conditions extends PushCondition {
}

/** Used by clients to submit authentication information to the interactive-authentication API */
export interface Anonymous101 {
    /** The value of the session key given by the homeserver. */
    session?: string | undefined;
    /** The authentication type that the client is attempting to complete.
May be omitted if `session` is given, and the client is reissuing a
request which it believes has been completed out-of-band (for example,
via the [fallback mechanism](#fallback)). */
    type?: string | undefined;

    [key: string]: any;
}

export interface Auth7 extends Anonymous101 {
}

/** The backed up keys for a room. */
export interface RoomKeyBackup3 {
    /** A map of session IDs to key data. */
    sessions: { [key: string]: Anonymous109; };
}

export interface Anonymous85 extends RoomKeyBackup3 {
}

/** The key data */
export interface KeyBackupData3 {
    /** The index of the first message in the session that the key can decrypt. */
    first_message_index: number;
    /** The number of times this key has been forwarded via key-sharing between devices. */
    forwarded_count: number;
    /** Whether the device backing up the key verified the device that the key
is from. */
    is_verified: boolean;
    /** Algorithm-dependent data.  See the documentation for the backup
algorithms in [Server-side key backups](https://spec.matrix.org/v1.5/client-server-api/#server-side-key-backups) for more information on the
expected format of the data. */
    session_data: any;
}

export interface Anonymous86 extends KeyBackupData3 {
}

export enum VersionAlgorithm {
    M_megolm_backup_v1_curve25519AesSha2 = "m.megolm_backup.v1.curve25519-aes-sha2",
}

export enum Version2Algorithm {
    M_megolm_backup_v1_curve25519AesSha2 = "m.megolm_backup.v1.curve25519-aes-sha2",
}

/** A signature of an `m.third_party_invite` token to prove that this user owns a third party identity which has been invited to the room. */
export interface Anonymous102 {
    /** The Matrix ID of the invitee. */
    mxid: string;
    /** The Matrix ID of the user who issued the invite. */
    sender: string;
    /** A signatures object containing a signature of the entire signed object. */
    signatures: { [key: string]: { [key: string]: string; }; };
    /** The state key of the m.third_party_invite event. */
    token: string;
}

export interface Third_party_signed2 extends Anonymous102 {
}

export interface Search_categories {
    /** Mapping of category name to search criteria. */
    room_events?: Room_events | undefined;
}

export interface MHomeserver {
    /** The base URL for the homeserver for client-server connections. */
    base_url: string;
}

export interface MIdentity_server {
    /** The base URL for the identity server for client-server connections. */
    base_url: string;
}

export interface PublicRoomsChunk {
    /** The URL for the room's avatar, if one is set. */
    avatar_url?: string | undefined;
    /** The canonical alias of the room, if any. */
    canonical_alias?: string | undefined;
    /** Whether guest users may join the room and participate in it.
If they can, they will be subject to ordinary power level
rules like any other user. */
    guest_can_join: boolean;
    /** The room's join rule. When not present, the room is assumed to
be `public`. */
    join_rule?: string | undefined;
    /** The name of the room, if any. */
    name?: string | undefined;
    /** The number of members joined to the room. */
    num_joined_members: number;
    /** The ID of the room. */
    room_id: string;
    /** The `type` of room (from [`m.room.create`](https://spec.matrix.org/v1.5/client-server-api/#mroomcreate)), if any. */
    room_type?: string | undefined;
    /** The topic of the room, if any. */
    topic?: string | undefined;
    /** Whether the room may be viewed by guest users without joining. */
    world_readable: boolean;
}

export interface Rooms extends PublicRoomsChunk {
    /** The [`m.space.child`](#mspacechild) events of the space-room, represented
as [Stripped State Events](#stripped-state) with an added `origin_server_ts` key.

If the room is not a space-room, this should be empty. */
    children_state: Children_state[];
    /** The `type` of room (from [`m.room.create`](https://spec.matrix.org/v1.5/client-server-api/#mroomcreate)), if any. */
    room_type?: string | undefined;
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface ClientEventWithoutRoomID14 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned38 | undefined;
}

/** The format used for events when they are returned from a homeserver to a client via the Client-Server API, or sent to an Application Service via the Application Services API. */
export interface ClientEvent4 extends ClientEventWithoutRoomID14 {
    /** The ID of the room associated with this event. */
    room_id: string;
    unsigned?: Unsigned18 | undefined;
}

export interface Chunk extends ClientEvent4 {
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface ClientEventWithoutRoomID15 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned39 | undefined;
}

/** The format used for events when they are returned from a homeserver to a client via the Client-Server API, or sent to an Application Service via the Application Services API. */
export interface ClientEvent5 extends ClientEventWithoutRoomID15 {
    /** The ID of the room associated with this event. */
    room_id: string;
    unsigned?: Unsigned19 | undefined;
}

export interface Chunk2 extends ClientEvent5 {
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface ClientEventWithoutRoomID16 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned40 | undefined;
}

/** The format used for events when they are returned from a homeserver to a client via the Client-Server API, or sent to an Application Service via the Application Services API. */
export interface ClientEvent6 extends ClientEventWithoutRoomID16 {
    /** The ID of the room associated with this event. */
    room_id: string;
    unsigned?: Unsigned20 | undefined;
}

export interface Chunk3 extends ClientEvent6 {
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface ClientEventWithoutRoomID4 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned21 | undefined;
}

/** The format used for events when they are returned from a homeserver to a client via the Client-Server API, or sent to an Application Service via the Application Services API. */
export interface Chunk4 extends ClientEventWithoutRoomID4 {
    /** The ID of the room associated with this event. */
    room_id: string;
    unsigned?: Unsigned4 | undefined;
}

export interface Threepids {
    /** The timestamp, in milliseconds, when the homeserver associated the third party identifier with the user. */
    added_at: number;
    /** The third party identifier address. */
    address: string;
    /** The medium of the third party identifier. */
    medium: ThreepidsMedium;
    /** The timestamp, in milliseconds, when the identifier was
validated by the identity server. */
    validated_at: number;
}

export interface Flows {
    /** The login type of each of the stages required to complete this
authentication flow */
    stages: string[];
}

export enum Id_server_unbind_result {
    NoSupport = "no-support",
    Success = "success",
}

export enum Id_server_unbind_result2 {
    NoSupport = "no-support",
    Success = "success",
}

export enum Id_server_unbind_result3 {
    Success = "success",
    NoSupport = "no-support",
}

export interface Flows2 {
    /** The login type of each of the stages required to complete this
authentication flow */
    stages: string[];
}

export interface Flows3 {
    /** The login type of each of the stages required to complete this
authentication flow */
    stages: string[];
}

export interface DeviceInfo {
    /** A user's sessions (i.e. what they did with an access token from one login). */
    sessions?: Sessions[] | undefined;
}

export interface Capabilities {
    /** Capability to indicate if the user can change their password. */
    "m.change_password"?: MChange_password | undefined;
    /** The room versions the server supports. */
    "m.room_versions"?: MRoom_versions | undefined;

    [key: string]: any;
}

export interface Flows4 {
    /** The login type of each of the stages required to complete this
authentication flow */
    stages: string[];
}

/** A client device */
export interface Device2 {
    /** Identifier of this device. */
    device_id: string;
    /** Display name set by the user for this device. Absent if no name has been
set. */
    display_name?: string | undefined;
    /** The IP address where this device was last seen. (May be a few minutes out
of date, for efficiency reasons). */
    last_seen_ip?: string | undefined;
    /** The timestamp (in milliseconds since the unix epoch) when this devices
was last seen. (May be a few minutes out of date, for efficiency
reasons). */
    last_seen_ts?: number | undefined;
}

export interface Devices extends Device2 {
}

export interface Flows5 {
    /** The login type of each of the stages required to complete this
authentication flow */
    stages: string[];
}

export enum Visibility {
    Private = "private",
    Public = "public",
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface ClientEventWithoutRoomID5 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned22 | undefined;
}

/** The format used for events when they are returned from a homeserver to a client via the Client-Server API, or sent to an Application Service via the Application Services API. */
export interface Chunk5 extends ClientEventWithoutRoomID5 {
    /** The ID of the room associated with this event. */
    room_id: string;
    unsigned?: Unsigned5 | undefined;
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface ClientEventWithoutRoomID17 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned41 | undefined;
}

/** The format used for events when they are returned from a homeserver to a client via the Client-Server API, or sent to an Application Service via the Application Services API. */
export interface ClientEvent7 extends ClientEventWithoutRoomID17 {
    /** The ID of the room associated with this event. */
    room_id: string;
    unsigned?: Unsigned23 | undefined;
}

export interface Chunk6 extends ClientEvent7 {
}

export interface Unsigned {
    redacted_because?: any | undefined;
}

/** The basic set of fields all events must have. */
export interface Event2 {
    /** The fields in this object will vary depending on the type of event. When interacting with the REST API, this is the HTTP body. */
    content: any;
    /** The type of event. This SHOULD be namespaced similar to Java package naming conventions e.g. 'com.example.subdomain.event.type' */
    type: string;
}

export interface Account_data extends Event2 {
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface ClientEventWithoutRoomID6 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned24 | undefined;
}

/** The format used for events when they are returned from a homeserver to a client via the Client-Server API, or sent to an Application Service via the Application Services API. */
export interface Presence extends ClientEventWithoutRoomID6 {
    /** The ID of the room associated with this event. */
    room_id: string;
    unsigned?: Unsigned7 | undefined;
}

export interface Rooms2 {
    /** The private data that this user has attached to
this room. */
    account_data?: Account_data5[] | undefined;
    /** The invite event if `membership` is `invite` */
    invite?: Invite | undefined;
    /** The user's membership state in this room. */
    membership: Rooms2Membership;
    /** The pagination chunk for this room. */
    messages?: Messages2 | undefined;
    /** The ID of this room. */
    room_id: string;
    /** If the user is a member of the room this will be the
current state of the room as a list of events. If the
user has left the room this will be the state of the
room when they left it. */
    state?: State4[] | undefined;
    /** Whether this room is visible to the `/publicRooms` API
or not." */
    visibility?: Rooms2Visibility | undefined;
}

/** Device identity keys */
export interface DeviceKeys2 {
    /** The encryption algorithms supported by this device. */
    algorithms: string[];
    /** The ID of the device these keys belong to. Must match the device ID used
when logging in. */
    device_id: string;
    /** Public identity keys. The names of the properties should be in the
format `<algorithm>:<device_id>`. The keys themselves should be
encoded as specified by the key algorithm. */
    keys: { [key: string]: string; };
    /** Signatures for the device key object. A map from user ID, to a map from
`<algorithm>:<device_id>` to the signature.

The signature is calculated using the process described at [Signing JSON](https://spec.matrix.org/v1.5/appendices/#signing-json). */
    signatures: { [key: string]: { [key: string]: string; }; };
    /** The ID of the user the device belongs to. Must match the user ID used
when logging in. */
    user_id: string;
}

export interface DeviceInformation extends DeviceKeys2 {
    /** Additional data added to the device key information
by intermediate servers, and not covered by the
signatures. */
    unsigned?: Unsigned8 | undefined;
}

/** Cross signing key */
export interface CrossSigningKey4 {
    /** The public key.  The object must have exactly one property, whose name is
in the form `<algorithm>:<unpadded_base64_public_key>`, and whose value
is the unpadded base64 public key. */
    keys: { [key: string]: string; };
    /** Signatures of the key, calculated using the process described at [Signing JSON](https://spec.matrix.org/v1.5/appendices/#signing-json).
Optional for the master key. Other keys must be signed by the
user\'s master key. */
    signatures?: any | undefined;
    /** What the key is used for. */
    usage: Usage4[];
    /** The ID of the user the key belongs to. */
    user_id: string;
}

export interface Anonymous87 extends CrossSigningKey4 {
}

/** Cross signing key */
export interface CrossSigningKey5 {
    /** The public key.  The object must have exactly one property, whose name is
in the form `<algorithm>:<unpadded_base64_public_key>`, and whose value
is the unpadded base64 public key. */
    keys: { [key: string]: string; };
    /** Signatures of the key, calculated using the process described at [Signing JSON](https://spec.matrix.org/v1.5/appendices/#signing-json).
Optional for the master key. Other keys must be signed by the
user\'s master key. */
    signatures?: any | undefined;
    /** What the key is used for. */
    usage: Usage5[];
    /** The ID of the user the key belongs to. */
    user_id: string;
}

export interface Anonymous88 extends CrossSigningKey5 {
}

/** Cross signing key */
export interface CrossSigningKey6 {
    /** The public key.  The object must have exactly one property, whose name is
in the form `<algorithm>:<unpadded_base64_public_key>`, and whose value
is the unpadded base64 public key. */
    keys: { [key: string]: string; };
    /** Signatures of the key, calculated using the process described at [Signing JSON](https://spec.matrix.org/v1.5/appendices/#signing-json).
Optional for the master key. Other keys must be signed by the
user\'s master key. */
    signatures?: any | undefined;
    /** What the key is used for. */
    usage: Usage6[];
    /** The ID of the user the key belongs to. */
    user_id: string;
}

export interface Anonymous89 extends CrossSigningKey6 {
}

export interface Flows6 {
    /** The login type. This is supplied as the `type` when
logging in. */
    type?: string | undefined;
}

/** Used by clients to determine the homeserver, identity server, and other optional components they should be interacting with. */
export interface Anonymous103 {
    /** Used by clients to discover homeserver information. */
    "m.homeserver": MHomeserver2;
    /** Used by clients to discover identity server information. */
    "m.identity_server"?: MIdentity_server2 | undefined;

    [key: string]: any;
}

export interface Well_known extends Anonymous103 {
}

export interface Notifications {
    /** The action(s) to perform when the conditions for this rule are met.
See [Push Rules: API](https://spec.matrix.org/v1.5/client-server-api/#push-rules-api). */
    actions: any[];
    /** The Event object for the event that triggered the notification. */
    event: Event3;
    /** The profile tag of the rule that matched this event. */
    profile_tag?: string | undefined;
    /** Indicates whether the user has sent a read receipt indicating
that they have read this message. */
    read: boolean;
    /** The ID of the room in which the event was posted. */
    room_id: string;
    /** The unix timestamp at which the event notification was sent,
in milliseconds. */
    ts: number;
}

export enum Presence2 {
    Online = "online",
    Offline = "offline",
    Unavailable = "unavailable",
}

export interface PublicRoomsChunk2 {
    /** The URL for the room's avatar, if one is set. */
    avatar_url?: string | undefined;
    /** The canonical alias of the room, if any. */
    canonical_alias?: string | undefined;
    /** Whether guest users may join the room and participate in it.
If they can, they will be subject to ordinary power level
rules like any other user. */
    guest_can_join: boolean;
    /** The room's join rule. When not present, the room is assumed to
be `public`. */
    join_rule?: string | undefined;
    /** The name of the room, if any. */
    name?: string | undefined;
    /** The number of members joined to the room. */
    num_joined_members: number;
    /** The ID of the room. */
    room_id: string;
    /** The `type` of room (from [`m.room.create`](https://spec.matrix.org/v1.5/client-server-api/#mroomcreate)), if any. */
    room_type?: string | undefined;
    /** The topic of the room, if any. */
    topic?: string | undefined;
    /** Whether the room may be viewed by guest users without joining. */
    world_readable: boolean;
}

export interface Chunk7 extends PublicRoomsChunk2 {
    /** The room's join rule. When not present, the room is assumed to
be `public`. Note that rooms with `invite` join rules are not
expected here, but rooms with `knock` rules are given their
near-public nature. */
    join_rule?: string | undefined;
}

export interface PublicRoomsChunk3 {
    /** The URL for the room's avatar, if one is set. */
    avatar_url?: string | undefined;
    /** The canonical alias of the room, if any. */
    canonical_alias?: string | undefined;
    /** Whether guest users may join the room and participate in it.
If they can, they will be subject to ordinary power level
rules like any other user. */
    guest_can_join: boolean;
    /** The room's join rule. When not present, the room is assumed to
be `public`. */
    join_rule?: string | undefined;
    /** The name of the room, if any. */
    name?: string | undefined;
    /** The number of members joined to the room. */
    num_joined_members: number;
    /** The ID of the room. */
    room_id: string;
    /** The `type` of room (from [`m.room.create`](https://spec.matrix.org/v1.5/client-server-api/#mroomcreate)), if any. */
    room_type?: string | undefined;
    /** The topic of the room, if any. */
    topic?: string | undefined;
    /** Whether the room may be viewed by guest users without joining. */
    world_readable: boolean;
}

export interface Chunk8 extends PublicRoomsChunk3 {
    /** The room's join rule. When not present, the room is assumed to
be `public`. Note that rooms with `invite` join rules are not
expected here, but rooms with `knock` rules are given their
near-public nature. */
    join_rule?: string | undefined;
}

export interface Pushers {
    /** A string that will allow the user to identify what application
owns this pusher. */
    app_display_name: string;
    /** This is a reverse-DNS style identifier for the application.
Max length, 64 chars. */
    app_id: string;
    /** A dictionary of information for the pusher implementation
itself. */
    data: Data2;
    /** A string that will allow the user to identify what device owns
this pusher. */
    device_display_name: string;
    /** The kind of pusher. `"http"` is a pusher that
sends HTTP pokes. */
    kind: string;
    /** The preferred language for receiving notifications (e.g. 'en'
or 'en-US') */
    lang: string;
    /** This string determines which set of device specific rules this
pusher executes. */
    profile_tag?: string | undefined;
    /** This is a unique identifier for this pusher. See `/set` for
more detail.
Max length, 512 bytes. */
    pushkey: string;
}

export interface Anonymous104 {
    content?: Content[] | undefined;
    override?: Override[] | undefined;
    room?: Room3[] | undefined;
    sender?: Sender[] | undefined;
    underride?: Underride[] | undefined;
}

export interface Global extends Anonymous104 {
}

export interface Flows7 {
    /** The login type of each of the stages required to complete this
authentication flow */
    stages: string[];
}

/** The backed up keys for a room. */
export interface RoomKeyBackup4 {
    /** A map of session IDs to key data. */
    sessions: { [key: string]: Anonymous110; };
}

export interface Anonymous90 extends RoomKeyBackup4 {
}

/** The key data */
export interface KeyBackupData4 {
    /** The index of the first message in the session that the key can decrypt. */
    first_message_index: number;
    /** The number of times this key has been forwarded via key-sharing between devices. */
    forwarded_count: number;
    /** Whether the device backing up the key verified the device that the key
is from. */
    is_verified: boolean;
    /** Algorithm-dependent data.  See the documentation for the backup
algorithms in [Server-side key backups](https://spec.matrix.org/v1.5/client-server-api/#server-side-key-backups) for more information on the
expected format of the data. */
    session_data: any;
}

export interface Anonymous91 extends KeyBackupData4 {
}

export enum Algorithm {
    M_megolm_backup_v1_curve25519AesSha2 = "m.megolm_backup.v1.curve25519-aes-sha2",
}

export enum Algorithm2 {
    M_megolm_backup_v1_curve25519AesSha2 = "m.megolm_backup.v1.curve25519-aes-sha2",
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface ClientEventWithoutRoomID21 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned46 | undefined;
}

/** The format used for events when they are returned from a homeserver to a client via the Client-Server API, or sent to an Application Service via the Application Services API. */
export interface ClientEvent8 extends ClientEventWithoutRoomID21 {
    /** The ID of the room associated with this event. */
    room_id: string;
    unsigned?: Unsigned29 | undefined;
}

export interface Event extends ClientEvent8 {
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface ClientEventWithoutRoomID7 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned30 | undefined;
}

/** The format used for events when they are returned from a homeserver to a client via the Client-Server API, or sent to an Application Service via the Application Services API. */
export interface Events_after extends ClientEventWithoutRoomID7 {
    /** The ID of the room associated with this event. */
    room_id: string;
    unsigned?: Unsigned9 | undefined;
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface ClientEventWithoutRoomID8 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned31 | undefined;
}

/** The format used for events when they are returned from a homeserver to a client via the Client-Server API, or sent to an Application Service via the Application Services API. */
export interface Events_before extends ClientEventWithoutRoomID8 {
    /** The ID of the room associated with this event. */
    room_id: string;
    unsigned?: Unsigned10 | undefined;
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface ClientEventWithoutRoomID9 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned32 | undefined;
}

/** The format used for events when they are returned from a homeserver to a client via the Client-Server API, or sent to an Application Service via the Application Services API. */
export interface State extends ClientEventWithoutRoomID9 {
    /** The ID of the room associated with this event. */
    room_id: string;
    unsigned?: Unsigned11 | undefined;
}

export interface Unsigned2 {
    redacted_because?: any | undefined;
}

/** The basic set of fields all events must have. */
export interface Event4 {
    /** The fields in this object will vary depending on the type of event. When interacting with the REST API, this is the HTTP body. */
    content: any;
    /** The type of event. This SHOULD be namespaced similar to Java package naming conventions e.g. 'com.example.subdomain.event.type' */
    type: string;
}

export interface Account_data2 extends Event4 {
}

export enum RoomInfoMembership {
    Invite = "invite",
    Join = "join",
    Leave = "leave",
    Ban = "ban",
}

export interface Messages {
    /** If the user is a member of the room this will be a
list of the most recent messages for this room. If
the user has left the room this will be the
messages that preceded them leaving. This array
will consist of at most `limit` elements. */
    chunk: Chunk11[];
    /** A token which correlates to the end of `chunk`. Can be passed to
[`/rooms/<room_id>/messages`](#get_matrixclientv3roomsroomidmessages)
to retrieve later events. */
    end: string;
    /** A token which correlates to the start of `chunk`. Can be passed to
[`/rooms/<room_id>/messages`](#get_matrixclientv3roomsroomidmessages)
to retrieve earlier events.

If no earlier events are available, this property may be omitted from
the response. */
    start?: string | undefined;
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface ClientEventWithoutRoomID10 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned34 | undefined;
}

/** The format used for events when they are returned from a homeserver to a client via the Client-Server API, or sent to an Application Service via the Application Services API. */
export interface State2 extends ClientEventWithoutRoomID10 {
    /** The ID of the room associated with this event. */
    room_id: string;
    unsigned?: Unsigned13 | undefined;
}

export enum RoomInfoVisibility {
    Private = "private",
    Public = "public",
}

export interface RoomMember {
    /** The mxc avatar url of the user this object is representing. */
    avatar_url?: string | undefined;
    /** The display name of the user this object is representing. */
    display_name?: string | undefined;
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface ClientEventWithoutRoomID11 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned35 | undefined;
}

/** The format used for events when they are returned from a homeserver to a client via the Client-Server API, or sent to an Application Service via the Application Services API. */
export interface Chunk9 extends ClientEventWithoutRoomID11 {
    /** The ID of the room associated with this event. */
    room_id: string;
    unsigned?: Unsigned14 | undefined;
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface ClientEventWithoutRoomID12 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned36 | undefined;
}

/** The format used for events when they are returned from a homeserver to a client via the Client-Server API, or sent to an Application Service via the Application Services API. */
export interface Chunk10 extends ClientEventWithoutRoomID12 {
    /** The ID of the room associated with this event. */
    room_id: string;
    unsigned?: Unsigned15 | undefined;
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface ClientEventWithoutRoomID13 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned37 | undefined;
}

/** The format used for events when they are returned from a homeserver to a client via the Client-Server API, or sent to an Application Service via the Application Services API. */
export interface State3 extends ClientEventWithoutRoomID13 {
    /** The ID of the room associated with this event. */
    room_id: string;
    unsigned?: Unsigned16 | undefined;
}

export interface Unsigned3 {
    redacted_because?: any | undefined;
}

export interface Search_categories2 {
    /** Mapping of category name to search criteria. */
    room_events?: Room_events2 | undefined;
}

export interface EventBatch {
    /** List of events. */
    events?: Events[] | undefined;
}

export interface Account_data3 extends EventBatch {
}

export interface EventBatch2 {
    /** List of events. */
    events?: Events2[] | undefined;
}

export interface Presence3 extends EventBatch2 {
}

export interface Rooms3 {
    /** The rooms that the user has been invited to, mapped as room ID to
room information. */
    invite?: { [key: string]: Anonymous105; } | undefined;
    /** The rooms that the user has joined, mapped as room ID to
room information. */
    join?: { [key: string]: Anonymous106; } | undefined;
    /** The rooms that the user has knocked upon, mapped as room ID to room information. */
    knock?: { [key: string]: Anonymous107; } | undefined;
    /** The rooms that the user has left or been banned from, mapped as room ID to
room information. */
    leave?: { [key: string]: Anonymous108; } | undefined;
}

/** Definition of valid values for a field. */
export interface Anonymous92 {
    /** An placeholder serving as a valid example of the field value. */
    placeholder: string;
    /** A regular expression for validation of a field's value. This may be relatively
coarse to verify the value as the application service providing this protocol
may apply additional validation or filtering. */
    regexp: string;
}

export interface Instances {
    /** A human-readable description for the protocol, such as the name. */
    desc: string;
    /** Preset values for `fields` the client may use to search by. */
    fields: any;
    /** An optional content URI representing the protocol. Overrides the one provided
at the higher level Protocol object. */
    icon?: string | undefined;
    /** A unique identifier across all instances. */
    network_id: string;
}

/** Definition of valid values for a field. */
export interface Anonymous93 {
    /** An placeholder serving as a valid example of the field value. */
    placeholder: string;
    /** A regular expression for validation of a field's value. This may be relatively
coarse to verify the value as the application service providing this protocol
may apply additional validation or filtering. */
    regexp: string;
}

export interface Instances2 {
    /** A human-readable description for the protocol, such as the name. */
    desc: string;
    /** Preset values for `fields` the client may use to search by. */
    fields: any;
    /** An optional content URI representing the protocol. Overrides the one provided
at the higher level Protocol object. */
    icon?: string | undefined;
    /** A unique identifier across all instances. */
    network_id: string;
}

export interface Tag {
    /** A number in a range `[0,1]` describing a relative
position of the room under the given tag. */
    order?: number | undefined;

    [key: string]: any;
}

export interface Results2 {
    /** The avatar url, as an MXC, if one exists. */
    avatar_url?: string | undefined;
    /** The display name of the user, if one exists. */
    display_name?: string | undefined;
    /** The user's matrix user ID. */
    user_id: string;
}

export interface Room_events {
    /** Configures whether any context for the events
returned are included in the response. */
    event_context?: Event_context | undefined;
    /** This takes a [filter](https://spec.matrix.org/v1.5/client-server-api/#filtering). */
    filter?: Filter5 | undefined;
    /** Requests that the server partitions the result set
based on the provided list of keys. */
    groupings?: Groupings | undefined;
    /** Requests the server return the current state for
each room returned. */
    include_state?: boolean | undefined;
    /** The keys to search. Defaults to all. */
    keys?: Keys3[] | undefined;
    /** The order in which to search for results.
By default, this is `"rank"`. */
    order_by?: Room_eventsOrder_by | undefined;
    /** The string to search events for */
    search_term: string;
}

export interface EventFilter {
    /** The maximum number of events to return. */
    limit?: number | undefined;
    /** A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the `'senders'` filter. */
    not_senders?: string[] | undefined;
    /** A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the `'types'` filter. A '*' can be used as a wildcard to match any sequence of characters. */
    not_types?: string[] | undefined;
    /** A list of senders IDs to include. If this list is absent then all senders are included. */
    senders?: string[] | undefined;
    /** A list of event types to include. If this list is absent then all event types are included. A `'*'` can be used as a wildcard to match any sequence of characters. */
    types?: string[] | undefined;
}

export interface Account_data4 extends EventFilter {
}

export enum Filter3Event_format {
    Client = "client",
    Federation = "federation",
}

export interface EventFilter2 {
    /** The maximum number of events to return. */
    limit?: number | undefined;
    /** A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the `'senders'` filter. */
    not_senders?: string[] | undefined;
    /** A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the `'types'` filter. A '*' can be used as a wildcard to match any sequence of characters. */
    not_types?: string[] | undefined;
    /** A list of senders IDs to include. If this list is absent then all senders are included. */
    senders?: string[] | undefined;
    /** A list of event types to include. If this list is absent then all event types are included. A `'*'` can be used as a wildcard to match any sequence of characters. */
    types?: string[] | undefined;
}

export interface Presence4 extends EventFilter2 {
}

export interface Room {
    /** The per user account data to include for rooms. */
    account_data?: Account_data7 | undefined;
    /** The ephemeral events to include for rooms. These are the events that appear in the `ephemeral` property in the `/sync` response. */
    ephemeral?: Ephemeral | undefined;
    /** Include rooms that the user has left in the sync, default false */
    include_leave?: boolean | undefined;
    /** A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the `'rooms'` filter. This filter is applied before the filters in `ephemeral`, `state`, `timeline` or `account_data` */
    not_rooms?: string[] | undefined;
    /** A list of room IDs to include. If this list is absent then all rooms are included. This filter is applied before the filters in `ephemeral`, `state`, `timeline` or `account_data` */
    rooms?: string[] | undefined;
    /** The state events to include for rooms. */
    state?: State5 | undefined;
    /** The message and state update events to include for rooms. */
    timeline?: Timeline | undefined;
}

/** A stripped down state event, with only the `type`, `state_key`, `sender`, and `content` keys. */
export interface StrippedStateEvent {
    /** The `content` for the event. */
    content: any;
    /** The `sender` for the event. */
    sender: string;
    /** The `state_key` for the event. */
    state_key: string;
    /** The `type` for the event. */
    type: string;
}

export interface Children_state extends StrippedStateEvent {
    /** The `origin_server_ts` for the event. */
    origin_server_ts: number;
}

export interface Unsigned4 {
    redacted_because?: any | undefined;
}

export enum ThreepidsMedium {
    Email = "email",
    Msisdn = "msisdn",
}

export interface Sessions {
    /** Information particular connections in the session. */
    connections?: Connections[] | undefined;
}

export interface MChange_password {
    /** True if the user can change their password, false otherwise. */
    enabled: boolean;
}

export interface MRoom_versions {
    /** A detailed description of the room versions the server supports. */
    available: { [key: string]: RoomVersionStability; };
    /** The default room version the server is using for new rooms. */
    default: string;
}

export interface Unsigned5 {
    redacted_because?: any | undefined;
}

export interface Unsigned6 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface Unsigned7 {
    redacted_because?: any | undefined;
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface ClientEventWithoutRoomID18 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned42 | undefined;
}

/** The format used for events when they are returned from a homeserver to a client via the Client-Server API, or sent to an Application Service via the Application Services API. */
export interface Account_data5 extends ClientEventWithoutRoomID18 {
    /** The ID of the room associated with this event. */
    room_id: string;
    unsigned?: Unsigned25 | undefined;
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface ClientEventWithoutRoomID19 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned43 | undefined;
}

export interface Invite extends ClientEventWithoutRoomID19 {
    /** The ID of the room associated with this event. */
    room_id: string;
    unsigned?: Unsigned26 | undefined;
}

export enum Rooms2Membership {
    Invite = "invite",
    Join = "join",
    Leave = "leave",
    Ban = "ban",
}

export interface Messages2 {
    /** If the user is a member of the room this will be a
list of the most recent messages for this room. If
the user has left the room this will be the
messages that preceded them leaving. This array
will consist of at most `limit` elements. */
    chunk: Chunk12[];
    /** A token which correlates to the end of `chunk`.
Can be passed to
[`/rooms/<room_id>/messages`](#get_matrixclientv3roomsroomidmessages)
to retrieve later events. */
    end: string;
    /** A token which correlates to the start of `chunk`.
Can be passed to
[`/rooms/<room_id>/messages`](#get_matrixclientv3roomsroomidmessages)
to retrieve earlier events.

If no earlier events are available, this property may be omitted from
the response. */
    start?: string | undefined;
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface ClientEventWithoutRoomID20 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned45 | undefined;
}

/** The format used for events when they are returned from a homeserver to a client via the Client-Server API, or sent to an Application Service via the Application Services API. */
export interface State4 extends ClientEventWithoutRoomID20 {
    /** The ID of the room associated with this event. */
    room_id: string;
    unsigned?: Unsigned27 | undefined;
}

export enum Rooms2Visibility {
    Private = "private",
    Public = "public",
}

export interface Unsigned8 {
    /** The display name which the user set on the device. */
    device_display_name?: string | undefined;
}

export interface Event3 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned28 | undefined;
}

export interface Data2 {
    /** The format to use when sending notifications to the Push
Gateway. */
    format?: string | undefined;
    /** Required if `kind` is `http`. The URL to use to send
notifications to. */
    url?: string | undefined;
}

export interface PushCondition2 {
    /** Required for `room_member_count` conditions. A decimal integer
optionally prefixed by one of, ==, <, >, >= or <=. A prefix of < matches
rooms where the member count is strictly less than the given number and
so forth. If no prefix is present, this parameter defaults to ==. */
    is?: string | undefined;
    /** Required for `event_match` conditions. The dot-separated field of the
event to match.

Required for `sender_notification_permission` conditions. The field in
the power level event the user needs a minimum power level for. Fields
must be specified under the `notifications` property in the power level
event's `content`. */
    key?: string | undefined;
    /** The kind of condition to apply. See [conditions](https://spec.matrix.org/v1.5/client-server-api/#conditions) for
more information on the allowed kinds and how they work. */
    kind: string;
    /** Required for `event_match` conditions. The glob-style pattern to
match against. */
    pattern?: string | undefined;
}

export interface Conditions2 extends PushCondition2 {
}

export interface Unsigned9 {
    redacted_because?: any | undefined;
}

export interface Unsigned10 {
    redacted_because?: any | undefined;
}

export interface Unsigned11 {
    redacted_because?: any | undefined;
}

export interface Unsigned12 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface ClientEventWithoutRoomID22 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned47 | undefined;
}

/** The format used for events when they are returned from a homeserver to a client via the Client-Server API, or sent to an Application Service via the Application Services API. */
export interface Chunk11 extends ClientEventWithoutRoomID22 {
    /** The ID of the room associated with this event. */
    room_id: string;
    unsigned?: Unsigned33 | undefined;
}

export interface Unsigned13 {
    redacted_because?: any | undefined;
}

export interface Unsigned14 {
    redacted_because?: any | undefined;
}

export interface Unsigned15 {
    redacted_because?: any | undefined;
}

export interface Unsigned16 {
    redacted_because?: any | undefined;
}

export interface Unsigned17 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface Room_events2 {
    /** An approximate count of the total number of results found. */
    count?: number | undefined;
    /** Any groups that were requested.

The outer `string` key is the group key requested (eg: `room_id`
or `sender`). The inner `string` key is the grouped value (eg:
a room's ID or a user's ID). */
    groups?: { [key: string]: { [key: string]: Anonymous111; }; } | undefined;
    /** List of words which should be highlighted, useful for stemming which may change the query terms. */
    highlights?: string[] | undefined;
    /** Token that can be used to get the next batch of
results, by passing as the `next_batch` parameter to
the next call. If this field is absent, there are no
more results. */
    next_batch?: string | undefined;
    /** List of results in the requested order. */
    results?: Results3[] | undefined;
    /** The current state for every room in the results.
This is included if the request had the
`include_state` key set with a value of `true`.

The `string` key is the room ID for which the `State
Event` array belongs to. */
    state?: { [key: string]: ClientEvent9[]; } | undefined;
}

export interface Anonymous105 {
    /** The [stripped state](#stripped-state) of a room that the user has been invited
to. */
    invite_state?: Invite_state | undefined;
}

export interface Anonymous106 {
    /** The private data that this user has attached to
this room. */
    account_data?: Account_data8 | undefined;
    /** The new ephemeral events in the room (events that
aren't recorded in the timeline or state of the
room). In this version of the spec, these are
[typing notification](#typing-notifications) and
[read receipt](#receipts) events. */
    ephemeral?: Ephemeral2 | undefined;
    /** Updates to the state, between the time indicated by
the `since` parameter, and the start of the
`timeline` (or all state up to the start of the
`timeline`, if `since` is not given, or
`full_state` is true).

N.B. state updates for `m.room.member` events will
be incomplete if `lazy_load_members` is enabled in
the `/sync` filter, and only return the member events
required to display the senders of the timeline events
in this response. */
    state?: State6 | undefined;
    /** Information about the room which clients may need to
correctly render it to users. */
    summary?: Summary | undefined;
    /** The timeline of messages and state changes in the
room. */
    timeline?: Timeline2 | undefined;
    /** Counts of unread notifications for this room. See the
[Receiving notifications](https://spec.matrix.org/v1.5/client-server-api/#receiving-notifications) section
for more information on how these are calculated.

If `unread_thread_notifications` was specified as `true` on the `RoomEventFilter`,
these counts will only be for the main timeline rather than all events in the room.
See the [threading module](#threading) for more information. */
    unread_notifications?: Unread_notifications | undefined;
    /** If `unread_thread_notifications` was specified as `true` on the `RoomEventFilter`,
the notification counts for each [thread](#threading) in this room. The object is
keyed by thread root ID, with values matching `unread_notifications`.

If a thread does not have any notifications it can be omitted from this object. If
no threads have notification counts, this whole object can be omitted. */
    unread_thread_notifications?: { [key: string]: ThreadNotificationCounts; } | undefined;
}

export interface Anonymous107 {
    /** The [stripped state](#stripped-state) of a room that the user has knocked upon. */
    knock_state?: Knock_state | undefined;
}

export interface Anonymous108 {
    /** The private data that this user has attached to
this room. */
    account_data?: Account_data9 | undefined;
    /** The state updates for the room up to the start of the timeline. */
    state?: State7 | undefined;
    /** The timeline of messages and state changes in the
room up to the point when the user left. */
    timeline?: Timeline3 | undefined;
}

export interface EventFilter3 {
    /** The maximum number of events to return. */
    limit?: number | undefined;
    /** A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the `'senders'` filter. */
    not_senders?: string[] | undefined;
    /** A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the `'types'` filter. A '*' can be used as a wildcard to match any sequence of characters. */
    not_types?: string[] | undefined;
    /** A list of senders IDs to include. If this list is absent then all senders are included. */
    senders?: string[] | undefined;
    /** A list of event types to include. If this list is absent then all event types are included. A `'*'` can be used as a wildcard to match any sequence of characters. */
    types?: string[] | undefined;
}

export interface Account_data6 extends EventFilter3 {
}

export enum Filter4Event_format {
    Client = "client",
    Federation = "federation",
}

export interface EventFilter4 {
    /** The maximum number of events to return. */
    limit?: number | undefined;
    /** A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the `'senders'` filter. */
    not_senders?: string[] | undefined;
    /** A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the `'types'` filter. A '*' can be used as a wildcard to match any sequence of characters. */
    not_types?: string[] | undefined;
    /** A list of senders IDs to include. If this list is absent then all senders are included. */
    senders?: string[] | undefined;
    /** A list of event types to include. If this list is absent then all event types are included. A `'*'` can be used as a wildcard to match any sequence of characters. */
    types?: string[] | undefined;
}

export interface Presence5 extends EventFilter4 {
}

export interface Room2 {
    /** The per user account data to include for rooms. */
    account_data?: Account_data10 | undefined;
    /** The ephemeral events to include for rooms. These are the events that appear in the `ephemeral` property in the `/sync` response. */
    ephemeral?: Ephemeral3 | undefined;
    /** Include rooms that the user has left in the sync, default false */
    include_leave?: boolean | undefined;
    /** A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the `'rooms'` filter. This filter is applied before the filters in `ephemeral`, `state`, `timeline` or `account_data` */
    not_rooms?: string[] | undefined;
    /** A list of room IDs to include. If this list is absent then all rooms are included. This filter is applied before the filters in `ephemeral`, `state`, `timeline` or `account_data` */
    rooms?: string[] | undefined;
    /** The state events to include for rooms. */
    state?: State8 | undefined;
    /** The message and state update events to include for rooms. */
    timeline?: Timeline4 | undefined;
}

export enum Usage {
    Master = "master",
    Self_signing = "self_signing",
    User_signing = "user_signing",
}

export enum Usage2 {
    Master = "master",
    Self_signing = "self_signing",
    User_signing = "user_signing",
}

export enum Usage3 {
    Master = "master",
    Self_signing = "self_signing",
    User_signing = "user_signing",
}

/** The key data */
export interface KeyBackupData5 {
    /** The index of the first message in the session that the key can decrypt. */
    first_message_index: number;
    /** The number of times this key has been forwarded via key-sharing between devices. */
    forwarded_count: number;
    /** Whether the device backing up the key verified the device that the key
is from. */
    is_verified: boolean;
    /** Algorithm-dependent data.  See the documentation for the backup
algorithms in [Server-side key backups](https://spec.matrix.org/v1.5/client-server-api/#server-side-key-backups) for more information on the
expected format of the data. */
    session_data: any;
}

export interface Anonymous109 extends KeyBackupData5 {
}

export interface Event_context {
    /** How many events after the result are
returned. By default, this is `5`. */
    after_limit?: number | undefined;
    /** How many events before the result are
returned. By default, this is `5`. */
    before_limit?: number | undefined;
    /** Requests that the server returns the
historic profile information for the users
that sent the events that were returned.
By default, this is `false`. */
    include_profile?: boolean | undefined;
}

export interface EventFilter5 {
    /** The maximum number of events to return. */
    limit?: number | undefined;
    /** A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the `'senders'` filter. */
    not_senders?: string[] | undefined;
    /** A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the `'types'` filter. A '*' can be used as a wildcard to match any sequence of characters. */
    not_types?: string[] | undefined;
    /** A list of senders IDs to include. If this list is absent then all senders are included. */
    senders?: string[] | undefined;
    /** A list of event types to include. If this list is absent then all event types are included. A `'*'` can be used as a wildcard to match any sequence of characters. */
    types?: string[] | undefined;
}

export interface Anonymous112 extends EventFilter5 {
    /** If `true`, includes only events with a `url` key in their content. If `false`, excludes those events. If omitted, `url` key is not considered for filtering. */
    contains_url?: boolean | undefined;
    /** If `true`, sends all membership events for all events, even if they have already
been sent to the client. Does not
apply unless `lazy_load_members` is `true`. See
[Lazy-loading room members](https://spec.matrix.org/v1.5/client-server-api/#lazy-loading-room-members)
for more information. Defaults to `false`. */
    include_redundant_members?: boolean | undefined;
    /** If `true`, enables lazy-loading of membership events. See
[Lazy-loading room members](https://spec.matrix.org/v1.5/client-server-api/#lazy-loading-room-members)
for more information. Defaults to `false`. */
    lazy_load_members?: boolean | undefined;
    /** A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the `'rooms'` filter. */
    not_rooms?: string[] | undefined;
    /** A list of room IDs to include. If this list is absent then all rooms are included. */
    rooms?: string[] | undefined;
    /** If `true`, enables per-[thread](https://spec.matrix.org/v1.5/client-server-api/#threading) notification
counts. Only applies to the `/sync` endpoint. Defaults to `false`. */
    unread_thread_notifications?: boolean | undefined;
}

export interface Filter5 extends Anonymous112 {
}

export interface Groupings {
    /** List of groups to request. */
    group_by?: Group_by[] | undefined;
}

export enum Keys3 {
    Content_body = "content.body",
    Content_name = "content.name",
    Content_topic = "content.topic",
}

export enum Room_eventsOrder_by {
    Recent = "recent",
    Rank = "rank",
}

export interface EventFilter6 {
    /** The maximum number of events to return. */
    limit?: number | undefined;
    /** A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the `'senders'` filter. */
    not_senders?: string[] | undefined;
    /** A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the `'types'` filter. A '*' can be used as a wildcard to match any sequence of characters. */
    not_types?: string[] | undefined;
    /** A list of senders IDs to include. If this list is absent then all senders are included. */
    senders?: string[] | undefined;
    /** A list of event types to include. If this list is absent then all event types are included. A `'*'` can be used as a wildcard to match any sequence of characters. */
    types?: string[] | undefined;
}

export interface Anonymous113 extends EventFilter6 {
    /** If `true`, includes only events with a `url` key in their content. If `false`, excludes those events. If omitted, `url` key is not considered for filtering. */
    contains_url?: boolean | undefined;
    /** If `true`, sends all membership events for all events, even if they have already
been sent to the client. Does not
apply unless `lazy_load_members` is `true`. See
[Lazy-loading room members](https://spec.matrix.org/v1.5/client-server-api/#lazy-loading-room-members)
for more information. Defaults to `false`. */
    include_redundant_members?: boolean | undefined;
    /** If `true`, enables lazy-loading of membership events. See
[Lazy-loading room members](https://spec.matrix.org/v1.5/client-server-api/#lazy-loading-room-members)
for more information. Defaults to `false`. */
    lazy_load_members?: boolean | undefined;
    /** A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the `'rooms'` filter. */
    not_rooms?: string[] | undefined;
    /** A list of room IDs to include. If this list is absent then all rooms are included. */
    rooms?: string[] | undefined;
    /** If `true`, enables per-[thread](https://spec.matrix.org/v1.5/client-server-api/#threading) notification
counts. Only applies to the `/sync` endpoint. Defaults to `false`. */
    unread_thread_notifications?: boolean | undefined;
}

export interface Account_data7 extends Anonymous113 {
}

export interface EventFilter7 {
    /** The maximum number of events to return. */
    limit?: number | undefined;
    /** A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the `'senders'` filter. */
    not_senders?: string[] | undefined;
    /** A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the `'types'` filter. A '*' can be used as a wildcard to match any sequence of characters. */
    not_types?: string[] | undefined;
    /** A list of senders IDs to include. If this list is absent then all senders are included. */
    senders?: string[] | undefined;
    /** A list of event types to include. If this list is absent then all event types are included. A `'*'` can be used as a wildcard to match any sequence of characters. */
    types?: string[] | undefined;
}

export interface Anonymous114 extends EventFilter7 {
    /** If `true`, includes only events with a `url` key in their content. If `false`, excludes those events. If omitted, `url` key is not considered for filtering. */
    contains_url?: boolean | undefined;
    /** If `true`, sends all membership events for all events, even if they have already
been sent to the client. Does not
apply unless `lazy_load_members` is `true`. See
[Lazy-loading room members](https://spec.matrix.org/v1.5/client-server-api/#lazy-loading-room-members)
for more information. Defaults to `false`. */
    include_redundant_members?: boolean | undefined;
    /** If `true`, enables lazy-loading of membership events. See
[Lazy-loading room members](https://spec.matrix.org/v1.5/client-server-api/#lazy-loading-room-members)
for more information. Defaults to `false`. */
    lazy_load_members?: boolean | undefined;
    /** A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the `'rooms'` filter. */
    not_rooms?: string[] | undefined;
    /** A list of room IDs to include. If this list is absent then all rooms are included. */
    rooms?: string[] | undefined;
    /** If `true`, enables per-[thread](https://spec.matrix.org/v1.5/client-server-api/#threading) notification
counts. Only applies to the `/sync` endpoint. Defaults to `false`. */
    unread_thread_notifications?: boolean | undefined;
}

export interface Ephemeral extends Anonymous114 {
}

export interface EventFilter8 {
    /** The maximum number of events to return. */
    limit?: number | undefined;
    /** A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the `'senders'` filter. */
    not_senders?: string[] | undefined;
    /** A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the `'types'` filter. A '*' can be used as a wildcard to match any sequence of characters. */
    not_types?: string[] | undefined;
    /** A list of senders IDs to include. If this list is absent then all senders are included. */
    senders?: string[] | undefined;
    /** A list of event types to include. If this list is absent then all event types are included. A `'*'` can be used as a wildcard to match any sequence of characters. */
    types?: string[] | undefined;
}

export interface Anonymous115 extends EventFilter8 {
    /** If `true`, includes only events with a `url` key in their content. If `false`, excludes those events. If omitted, `url` key is not considered for filtering. */
    contains_url?: boolean | undefined;
    /** If `true`, sends all membership events for all events, even if they have already
been sent to the client. Does not
apply unless `lazy_load_members` is `true`. See
[Lazy-loading room members](https://spec.matrix.org/v1.5/client-server-api/#lazy-loading-room-members)
for more information. Defaults to `false`. */
    include_redundant_members?: boolean | undefined;
    /** If `true`, enables lazy-loading of membership events. See
[Lazy-loading room members](https://spec.matrix.org/v1.5/client-server-api/#lazy-loading-room-members)
for more information. Defaults to `false`. */
    lazy_load_members?: boolean | undefined;
    /** A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the `'rooms'` filter. */
    not_rooms?: string[] | undefined;
    /** A list of room IDs to include. If this list is absent then all rooms are included. */
    rooms?: string[] | undefined;
    /** If `true`, enables per-[thread](https://spec.matrix.org/v1.5/client-server-api/#threading) notification
counts. Only applies to the `/sync` endpoint. Defaults to `false`. */
    unread_thread_notifications?: boolean | undefined;
}

export interface State5 extends Anonymous115 {
}

export interface EventFilter9 {
    /** The maximum number of events to return. */
    limit?: number | undefined;
    /** A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the `'senders'` filter. */
    not_senders?: string[] | undefined;
    /** A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the `'types'` filter. A '*' can be used as a wildcard to match any sequence of characters. */
    not_types?: string[] | undefined;
    /** A list of senders IDs to include. If this list is absent then all senders are included. */
    senders?: string[] | undefined;
    /** A list of event types to include. If this list is absent then all event types are included. A `'*'` can be used as a wildcard to match any sequence of characters. */
    types?: string[] | undefined;
}

export interface Anonymous116 extends EventFilter9 {
    /** If `true`, includes only events with a `url` key in their content. If `false`, excludes those events. If omitted, `url` key is not considered for filtering. */
    contains_url?: boolean | undefined;
    /** If `true`, sends all membership events for all events, even if they have already
been sent to the client. Does not
apply unless `lazy_load_members` is `true`. See
[Lazy-loading room members](https://spec.matrix.org/v1.5/client-server-api/#lazy-loading-room-members)
for more information. Defaults to `false`. */
    include_redundant_members?: boolean | undefined;
    /** If `true`, enables lazy-loading of membership events. See
[Lazy-loading room members](https://spec.matrix.org/v1.5/client-server-api/#lazy-loading-room-members)
for more information. Defaults to `false`. */
    lazy_load_members?: boolean | undefined;
    /** A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the `'rooms'` filter. */
    not_rooms?: string[] | undefined;
    /** A list of room IDs to include. If this list is absent then all rooms are included. */
    rooms?: string[] | undefined;
    /** If `true`, enables per-[thread](https://spec.matrix.org/v1.5/client-server-api/#threading) notification
counts. Only applies to the `/sync` endpoint. Defaults to `false`. */
    unread_thread_notifications?: boolean | undefined;
}

export interface Timeline extends Anonymous116 {
}

export interface Unsigned18 {
    redacted_because?: any | undefined;
}

export interface Unsigned19 {
    redacted_because?: any | undefined;
}

export interface Unsigned20 {
    redacted_because?: any | undefined;
}

export interface Unsigned21 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface Connections {
    /** Most recently seen IP address of the session. */
    ip?: string | undefined;
    /** Unix timestamp that the session was last active. */
    last_seen?: number | undefined;
    /** User agent string last seen in the session. */
    user_agent?: string | undefined;
}

/** The stability of the room version. */
export enum RoomVersionStability {
    Stable = "stable",
    Unstable = "unstable",
}

export interface Unsigned22 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface Unsigned23 {
    redacted_because?: any | undefined;
}

export interface Unsigned24 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface Unsigned25 {
    redacted_because?: any | undefined;
}

export interface Unsigned26 {
    redacted_because?: any | undefined;
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface ClientEventWithoutRoomID23 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned49 | undefined;
}

/** The format used for events when they are returned from a homeserver to a client via the Client-Server API, or sent to an Application Service via the Application Services API. */
export interface Chunk12 extends ClientEventWithoutRoomID23 {
    /** The ID of the room associated with this event. */
    room_id: string;
    unsigned?: Unsigned44 | undefined;
}

export interface Unsigned27 {
    redacted_because?: any | undefined;
}

export enum Usage4 {
    Master = "master",
    Self_signing = "self_signing",
    User_signing = "user_signing",
}

export enum Usage5 {
    Master = "master",
    Self_signing = "self_signing",
    User_signing = "user_signing",
}

export enum Usage6 {
    Master = "master",
    Self_signing = "self_signing",
    User_signing = "user_signing",
}

export interface MHomeserver2 {
    /** The base URL for the homeserver for client-server connections. */
    base_url: string;
}

export interface MIdentity_server2 {
    /** The base URL for the identity server for client-server connections. */
    base_url: string;
}

export interface Unsigned28 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface PushRule2 {
    /** The actions to perform when this rule is matched. */
    actions: any[];
    /** The conditions that must hold true for an event in order for a rule to be
applied to an event. A rule with no conditions always matches. Only
applicable to `underride` and `override` rules. */
    conditions?: Conditions3[] | undefined;
    /** Whether this is a default rule, or has been set explicitly. */
    default: boolean;
    /** Whether the push rule is enabled or not. */
    enabled: boolean;
    /** The glob-style pattern to match against.  Only applicable to `content`
rules. */
    pattern?: string | undefined;
    /** The ID of this rule. */
    rule_id: string;
}

export interface Content extends PushRule2 {
}

export interface PushRule3 {
    /** The actions to perform when this rule is matched. */
    actions: any[];
    /** The conditions that must hold true for an event in order for a rule to be
applied to an event. A rule with no conditions always matches. Only
applicable to `underride` and `override` rules. */
    conditions?: Conditions4[] | undefined;
    /** Whether this is a default rule, or has been set explicitly. */
    default: boolean;
    /** Whether the push rule is enabled or not. */
    enabled: boolean;
    /** The glob-style pattern to match against.  Only applicable to `content`
rules. */
    pattern?: string | undefined;
    /** The ID of this rule. */
    rule_id: string;
}

export interface Override extends PushRule3 {
}

export interface PushRule4 {
    /** The actions to perform when this rule is matched. */
    actions: any[];
    /** The conditions that must hold true for an event in order for a rule to be
applied to an event. A rule with no conditions always matches. Only
applicable to `underride` and `override` rules. */
    conditions?: Conditions5[] | undefined;
    /** Whether this is a default rule, or has been set explicitly. */
    default: boolean;
    /** Whether the push rule is enabled or not. */
    enabled: boolean;
    /** The glob-style pattern to match against.  Only applicable to `content`
rules. */
    pattern?: string | undefined;
    /** The ID of this rule. */
    rule_id: string;
}

export interface Room3 extends PushRule4 {
}

export interface PushRule5 {
    /** The actions to perform when this rule is matched. */
    actions: any[];
    /** The conditions that must hold true for an event in order for a rule to be
applied to an event. A rule with no conditions always matches. Only
applicable to `underride` and `override` rules. */
    conditions?: Conditions6[] | undefined;
    /** Whether this is a default rule, or has been set explicitly. */
    default: boolean;
    /** Whether the push rule is enabled or not. */
    enabled: boolean;
    /** The glob-style pattern to match against.  Only applicable to `content`
rules. */
    pattern?: string | undefined;
    /** The ID of this rule. */
    rule_id: string;
}

export interface Sender extends PushRule5 {
}

export interface PushRule6 {
    /** The actions to perform when this rule is matched. */
    actions: any[];
    /** The conditions that must hold true for an event in order for a rule to be
applied to an event. A rule with no conditions always matches. Only
applicable to `underride` and `override` rules. */
    conditions?: Conditions7[] | undefined;
    /** Whether this is a default rule, or has been set explicitly. */
    default: boolean;
    /** Whether the push rule is enabled or not. */
    enabled: boolean;
    /** The glob-style pattern to match against.  Only applicable to `content`
rules. */
    pattern?: string | undefined;
    /** The ID of this rule. */
    rule_id: string;
}

export interface Underride extends PushRule6 {
}

/** The key data */
export interface KeyBackupData6 {
    /** The index of the first message in the session that the key can decrypt. */
    first_message_index: number;
    /** The number of times this key has been forwarded via key-sharing between devices. */
    forwarded_count: number;
    /** Whether the device backing up the key verified the device that the key
is from. */
    is_verified: boolean;
    /** Algorithm-dependent data.  See the documentation for the backup
algorithms in [Server-side key backups](https://spec.matrix.org/v1.5/client-server-api/#server-side-key-backups) for more information on the
expected format of the data. */
    session_data: any;
}

export interface Anonymous110 extends KeyBackupData6 {
}

export interface Unsigned29 {
    redacted_because?: any | undefined;
}

export interface Unsigned30 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface Unsigned31 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface Unsigned32 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface Unsigned33 {
    redacted_because?: any | undefined;
}

export interface Unsigned34 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface Unsigned35 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface Unsigned36 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface Unsigned37 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

/** The results for a particular group value. */
export interface Anonymous111 {
    /** Token that can be used to get the next batch
of results in the group, by passing as the
`next_batch` parameter to the next call. If
this field is absent, there are no more
results in this group. */
    next_batch?: string | undefined;
    /** Key that can be used to order different
groups. */
    order?: number | undefined;
    /** Which results are in this group. */
    results?: string[] | undefined;
}

/** The result object. */
export interface Results3 {
    /** Context for result, if requested. */
    context?: Context | undefined;
    /** A number that describes how closely this result matches the search. Higher is closer. */
    rank?: number | undefined;
    /** The event that matched. */
    result?: Result | undefined;
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface ClientEventWithoutRoomID24 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned51 | undefined;
}

/** The format used for events when they are returned from a homeserver to a client via the Client-Server API, or sent to an Application Service via the Application Services API. */
export interface ClientEvent9 extends ClientEventWithoutRoomID24 {
    /** The ID of the room associated with this event. */
    room_id: string;
    unsigned?: Unsigned48 | undefined;
}

/** The basic set of fields all events must have. */
export interface Event5 {
    /** The fields in this object will vary depending on the type of event. When interacting with the REST API, this is the HTTP body. */
    content: any;
    /** The type of event. This SHOULD be namespaced similar to Java package naming conventions e.g. 'com.example.subdomain.event.type' */
    type: string;
}

export interface Events extends Event5 {
}

/** The basic set of fields all events must have. */
export interface Event6 {
    /** The fields in this object will vary depending on the type of event. When interacting with the REST API, this is the HTTP body. */
    content: any;
    /** The type of event. This SHOULD be namespaced similar to Java package naming conventions e.g. 'com.example.subdomain.event.type' */
    type: string;
}

export interface Events2 extends Event6 {
}

export interface Invite_state {
    /** The [stripped state events](#stripped-state) that form the invite state. */
    events?: Events3[] | undefined;
}

export interface EventBatch3 {
    /** List of events. */
    events?: Events5[] | undefined;
}

export interface Account_data8 extends EventBatch3 {
}

export interface EventBatch4 {
    /** List of events. */
    events?: Events6[] | undefined;
}

export interface Ephemeral2 extends EventBatch4 {
}

export interface StateEventBatch {
    /** List of events. */
    events?: Events7[] | undefined;
}

export interface State6 extends StateEventBatch {
}

export interface Summary {
    /** The users which can be used to generate a room name
if the room does not have one. Required if the room's
`m.room.name` or `m.room.canonical_alias` state events
are unset or empty.

This should be the first 5 members of the room, ordered
by stream ordering, which are joined or invited. The
list must never include the client's own user ID. When
no joined or invited members are available, this should
consist of the banned and left users. More than 5 members
may be provided, however less than 5 should only be provided
when there are less than 5 members to represent.

When lazy-loading room members is enabled, the membership
events for the heroes MUST be included in the `state`,
unless they are redundant. When the list of users changes,
the server notifies the client by sending a fresh list of
heroes. If there are no changes since the last sync, this
field may be omitted. */
    "m.heroes"?: string[] | undefined;
    /** The number of users with `membership` of `invite`.
If this field has not changed since the last sync, it
may be omitted. Required otherwise. */
    "m.invited_member_count"?: number | undefined;
    /** The number of users with `membership` of `join`,
including the client's own user ID. If this field has
not changed since the last sync, it may be omitted.
Required otherwise. */
    "m.joined_member_count"?: number | undefined;
}

export interface TimelineBatch {
    /** List of events. */
    events: Events8[];
    /** True if the number of events returned was limited by the `limit` on the filter. */
    limited?: boolean | undefined;
    /** A token that can be supplied to the `from` parameter of the [`/rooms/<room_id>/messages`](#get_matrixclientv3roomsroomidmessages) endpoint in order to retrieve earlier events.
If no earlier events are available, this property may be omitted from the response. */
    prev_batch?: string | undefined;
}

export interface Timeline2 extends TimelineBatch {
}

export interface Unread_notifications {
    /** The number of unread notifications for this room with the highlight flag set. */
    highlight_count?: number | undefined;
    /** The total number of unread notifications for this room. */
    notification_count?: number | undefined;
}

export interface ThreadNotificationCounts {
    /** The number of unread notifications for this *thread* with the highlight flag set. */
    highlight_count?: number | undefined;
    /** The total number of unread notifications for this *thread*. */
    notification_count?: number | undefined;
}

export interface Knock_state {
    /** The [stripped state events](#stripped-state) that form the knock state. */
    events?: Events4[] | undefined;
}

export interface EventBatch5 {
    /** List of events. */
    events?: Events9[] | undefined;
}

export interface Account_data9 extends EventBatch5 {
}

export interface StateEventBatch2 {
    /** List of events. */
    events?: Events10[] | undefined;
}

export interface State7 extends StateEventBatch2 {
}

export interface TimelineBatch2 {
    /** List of events. */
    events: Events11[];
    /** True if the number of events returned was limited by the `limit` on the filter. */
    limited?: boolean | undefined;
    /** A token that can be supplied to the `from` parameter of the [`/rooms/<room_id>/messages`](#get_matrixclientv3roomsroomidmessages) endpoint in order to retrieve earlier events.
If no earlier events are available, this property may be omitted from the response. */
    prev_batch?: string | undefined;
}

export interface Timeline3 extends TimelineBatch2 {
}

export interface EventFilter10 {
    /** The maximum number of events to return. */
    limit?: number | undefined;
    /** A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the `'senders'` filter. */
    not_senders?: string[] | undefined;
    /** A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the `'types'` filter. A '*' can be used as a wildcard to match any sequence of characters. */
    not_types?: string[] | undefined;
    /** A list of senders IDs to include. If this list is absent then all senders are included. */
    senders?: string[] | undefined;
    /** A list of event types to include. If this list is absent then all event types are included. A `'*'` can be used as a wildcard to match any sequence of characters. */
    types?: string[] | undefined;
}

export interface Anonymous117 extends EventFilter10 {
    /** If `true`, includes only events with a `url` key in their content. If `false`, excludes those events. If omitted, `url` key is not considered for filtering. */
    contains_url?: boolean | undefined;
    /** If `true`, sends all membership events for all events, even if they have already
been sent to the client. Does not
apply unless `lazy_load_members` is `true`. See
[Lazy-loading room members](https://spec.matrix.org/v1.5/client-server-api/#lazy-loading-room-members)
for more information. Defaults to `false`. */
    include_redundant_members?: boolean | undefined;
    /** If `true`, enables lazy-loading of membership events. See
[Lazy-loading room members](https://spec.matrix.org/v1.5/client-server-api/#lazy-loading-room-members)
for more information. Defaults to `false`. */
    lazy_load_members?: boolean | undefined;
    /** A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the `'rooms'` filter. */
    not_rooms?: string[] | undefined;
    /** A list of room IDs to include. If this list is absent then all rooms are included. */
    rooms?: string[] | undefined;
    /** If `true`, enables per-[thread](https://spec.matrix.org/v1.5/client-server-api/#threading) notification
counts. Only applies to the `/sync` endpoint. Defaults to `false`. */
    unread_thread_notifications?: boolean | undefined;
}

export interface Account_data10 extends Anonymous117 {
}

export interface EventFilter11 {
    /** The maximum number of events to return. */
    limit?: number | undefined;
    /** A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the `'senders'` filter. */
    not_senders?: string[] | undefined;
    /** A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the `'types'` filter. A '*' can be used as a wildcard to match any sequence of characters. */
    not_types?: string[] | undefined;
    /** A list of senders IDs to include. If this list is absent then all senders are included. */
    senders?: string[] | undefined;
    /** A list of event types to include. If this list is absent then all event types are included. A `'*'` can be used as a wildcard to match any sequence of characters. */
    types?: string[] | undefined;
}

export interface Anonymous118 extends EventFilter11 {
    /** If `true`, includes only events with a `url` key in their content. If `false`, excludes those events. If omitted, `url` key is not considered for filtering. */
    contains_url?: boolean | undefined;
    /** If `true`, sends all membership events for all events, even if they have already
been sent to the client. Does not
apply unless `lazy_load_members` is `true`. See
[Lazy-loading room members](https://spec.matrix.org/v1.5/client-server-api/#lazy-loading-room-members)
for more information. Defaults to `false`. */
    include_redundant_members?: boolean | undefined;
    /** If `true`, enables lazy-loading of membership events. See
[Lazy-loading room members](https://spec.matrix.org/v1.5/client-server-api/#lazy-loading-room-members)
for more information. Defaults to `false`. */
    lazy_load_members?: boolean | undefined;
    /** A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the `'rooms'` filter. */
    not_rooms?: string[] | undefined;
    /** A list of room IDs to include. If this list is absent then all rooms are included. */
    rooms?: string[] | undefined;
    /** If `true`, enables per-[thread](https://spec.matrix.org/v1.5/client-server-api/#threading) notification
counts. Only applies to the `/sync` endpoint. Defaults to `false`. */
    unread_thread_notifications?: boolean | undefined;
}

export interface Ephemeral3 extends Anonymous118 {
}

export interface EventFilter12 {
    /** The maximum number of events to return. */
    limit?: number | undefined;
    /** A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the `'senders'` filter. */
    not_senders?: string[] | undefined;
    /** A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the `'types'` filter. A '*' can be used as a wildcard to match any sequence of characters. */
    not_types?: string[] | undefined;
    /** A list of senders IDs to include. If this list is absent then all senders are included. */
    senders?: string[] | undefined;
    /** A list of event types to include. If this list is absent then all event types are included. A `'*'` can be used as a wildcard to match any sequence of characters. */
    types?: string[] | undefined;
}

export interface Anonymous119 extends EventFilter12 {
    /** If `true`, includes only events with a `url` key in their content. If `false`, excludes those events. If omitted, `url` key is not considered for filtering. */
    contains_url?: boolean | undefined;
    /** If `true`, sends all membership events for all events, even if they have already
been sent to the client. Does not
apply unless `lazy_load_members` is `true`. See
[Lazy-loading room members](https://spec.matrix.org/v1.5/client-server-api/#lazy-loading-room-members)
for more information. Defaults to `false`. */
    include_redundant_members?: boolean | undefined;
    /** If `true`, enables lazy-loading of membership events. See
[Lazy-loading room members](https://spec.matrix.org/v1.5/client-server-api/#lazy-loading-room-members)
for more information. Defaults to `false`. */
    lazy_load_members?: boolean | undefined;
    /** A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the `'rooms'` filter. */
    not_rooms?: string[] | undefined;
    /** A list of room IDs to include. If this list is absent then all rooms are included. */
    rooms?: string[] | undefined;
    /** If `true`, enables per-[thread](https://spec.matrix.org/v1.5/client-server-api/#threading) notification
counts. Only applies to the `/sync` endpoint. Defaults to `false`. */
    unread_thread_notifications?: boolean | undefined;
}

export interface State8 extends Anonymous119 {
}

export interface EventFilter13 {
    /** The maximum number of events to return. */
    limit?: number | undefined;
    /** A list of sender IDs to exclude. If this list is absent then no senders are excluded. A matching sender will be excluded even if it is listed in the `'senders'` filter. */
    not_senders?: string[] | undefined;
    /** A list of event types to exclude. If this list is absent then no event types are excluded. A matching type will be excluded even if it is listed in the `'types'` filter. A '*' can be used as a wildcard to match any sequence of characters. */
    not_types?: string[] | undefined;
    /** A list of senders IDs to include. If this list is absent then all senders are included. */
    senders?: string[] | undefined;
    /** A list of event types to include. If this list is absent then all event types are included. A `'*'` can be used as a wildcard to match any sequence of characters. */
    types?: string[] | undefined;
}

export interface Anonymous120 extends EventFilter13 {
    /** If `true`, includes only events with a `url` key in their content. If `false`, excludes those events. If omitted, `url` key is not considered for filtering. */
    contains_url?: boolean | undefined;
    /** If `true`, sends all membership events for all events, even if they have already
been sent to the client. Does not
apply unless `lazy_load_members` is `true`. See
[Lazy-loading room members](https://spec.matrix.org/v1.5/client-server-api/#lazy-loading-room-members)
for more information. Defaults to `false`. */
    include_redundant_members?: boolean | undefined;
    /** If `true`, enables lazy-loading of membership events. See
[Lazy-loading room members](https://spec.matrix.org/v1.5/client-server-api/#lazy-loading-room-members)
for more information. Defaults to `false`. */
    lazy_load_members?: boolean | undefined;
    /** A list of room IDs to exclude. If this list is absent then no rooms are excluded. A matching room will be excluded even if it is listed in the `'rooms'` filter. */
    not_rooms?: string[] | undefined;
    /** A list of room IDs to include. If this list is absent then all rooms are included. */
    rooms?: string[] | undefined;
    /** If `true`, enables per-[thread](https://spec.matrix.org/v1.5/client-server-api/#threading) notification
counts. Only applies to the `/sync` endpoint. Defaults to `false`. */
    unread_thread_notifications?: boolean | undefined;
}

export interface Timeline4 extends Anonymous120 {
}

/** Configuration for group. */
export interface Group_by {
    /** Key that defines the group. */
    key?: Group_byKey | undefined;
}

export interface Unsigned38 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface Unsigned39 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface Unsigned40 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface Unsigned41 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface Unsigned42 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface Unsigned43 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface Unsigned44 {
    redacted_because?: any | undefined;
}

export interface Unsigned45 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface Unsigned46 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface Unsigned47 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface Context {
    /** Pagination token for the end of the chunk */
    end?: string | undefined;
    /** Events just after the result. */
    events_after?: Events_after2[] | undefined;
    /** Events just before the result. */
    events_before?: Events_before2[] | undefined;
    /** The historic profile information of the
users that sent the events returned.

The `string` key is the user ID for which
the profile belongs to. */
    profile_info?: { [key: string]: Anonymous121; } | undefined;
    /** Pagination token for the start of the chunk */
    start?: string | undefined;
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface ClientEventWithoutRoomID25 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned54 | undefined;
}

export interface Result extends ClientEventWithoutRoomID25 {
    /** The ID of the room associated with this event. */
    room_id: string;
    unsigned?: Unsigned50 | undefined;
}

export interface Unsigned48 {
    redacted_because?: any | undefined;
}

/** A stripped down state event, with only the `type`, `state_key`, `sender`, and `content` keys. */
export interface Events3 {
    /** The `content` for the event. */
    content: any;
    /** The `sender` for the event. */
    sender: string;
    /** The `state_key` for the event. */
    state_key: string;
    /** The `type` for the event. */
    type: string;
}

/** A stripped down state event, with only the `type`, `state_key`, `sender`, and `content` keys. */
export interface Events4 {
    /** The `content` for the event. */
    content: any;
    /** The `sender` for the event. */
    sender: string;
    /** The `state_key` for the event. */
    state_key: string;
    /** The `type` for the event. */
    type: string;
}

export enum Group_byKey {
    Room_id = "room_id",
    Sender = "sender",
}

export interface Unsigned49 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface PushCondition3 {
    /** Required for `room_member_count` conditions. A decimal integer
optionally prefixed by one of, ==, <, >, >= or <=. A prefix of < matches
rooms where the member count is strictly less than the given number and
so forth. If no prefix is present, this parameter defaults to ==. */
    is?: string | undefined;
    /** Required for `event_match` conditions. The dot-separated field of the
event to match.

Required for `sender_notification_permission` conditions. The field in
the power level event the user needs a minimum power level for. Fields
must be specified under the `notifications` property in the power level
event's `content`. */
    key?: string | undefined;
    /** The kind of condition to apply. See [conditions](https://spec.matrix.org/v1.5/client-server-api/#conditions) for
more information on the allowed kinds and how they work. */
    kind: string;
    /** Required for `event_match` conditions. The glob-style pattern to
match against. */
    pattern?: string | undefined;
}

export interface Conditions3 extends PushCondition3 {
}

export interface PushCondition4 {
    /** Required for `room_member_count` conditions. A decimal integer
optionally prefixed by one of, ==, <, >, >= or <=. A prefix of < matches
rooms where the member count is strictly less than the given number and
so forth. If no prefix is present, this parameter defaults to ==. */
    is?: string | undefined;
    /** Required for `event_match` conditions. The dot-separated field of the
event to match.

Required for `sender_notification_permission` conditions. The field in
the power level event the user needs a minimum power level for. Fields
must be specified under the `notifications` property in the power level
event's `content`. */
    key?: string | undefined;
    /** The kind of condition to apply. See [conditions](https://spec.matrix.org/v1.5/client-server-api/#conditions) for
more information on the allowed kinds and how they work. */
    kind: string;
    /** Required for `event_match` conditions. The glob-style pattern to
match against. */
    pattern?: string | undefined;
}

export interface Conditions4 extends PushCondition4 {
}

export interface PushCondition5 {
    /** Required for `room_member_count` conditions. A decimal integer
optionally prefixed by one of, ==, <, >, >= or <=. A prefix of < matches
rooms where the member count is strictly less than the given number and
so forth. If no prefix is present, this parameter defaults to ==. */
    is?: string | undefined;
    /** Required for `event_match` conditions. The dot-separated field of the
event to match.

Required for `sender_notification_permission` conditions. The field in
the power level event the user needs a minimum power level for. Fields
must be specified under the `notifications` property in the power level
event's `content`. */
    key?: string | undefined;
    /** The kind of condition to apply. See [conditions](https://spec.matrix.org/v1.5/client-server-api/#conditions) for
more information on the allowed kinds and how they work. */
    kind: string;
    /** Required for `event_match` conditions. The glob-style pattern to
match against. */
    pattern?: string | undefined;
}

export interface Conditions5 extends PushCondition5 {
}

export interface PushCondition6 {
    /** Required for `room_member_count` conditions. A decimal integer
optionally prefixed by one of, ==, <, >, >= or <=. A prefix of < matches
rooms where the member count is strictly less than the given number and
so forth. If no prefix is present, this parameter defaults to ==. */
    is?: string | undefined;
    /** Required for `event_match` conditions. The dot-separated field of the
event to match.

Required for `sender_notification_permission` conditions. The field in
the power level event the user needs a minimum power level for. Fields
must be specified under the `notifications` property in the power level
event's `content`. */
    key?: string | undefined;
    /** The kind of condition to apply. See [conditions](https://spec.matrix.org/v1.5/client-server-api/#conditions) for
more information on the allowed kinds and how they work. */
    kind: string;
    /** Required for `event_match` conditions. The glob-style pattern to
match against. */
    pattern?: string | undefined;
}

export interface Conditions6 extends PushCondition6 {
}

export interface PushCondition7 {
    /** Required for `room_member_count` conditions. A decimal integer
optionally prefixed by one of, ==, <, >, >= or <=. A prefix of < matches
rooms where the member count is strictly less than the given number and
so forth. If no prefix is present, this parameter defaults to ==. */
    is?: string | undefined;
    /** Required for `event_match` conditions. The dot-separated field of the
event to match.

Required for `sender_notification_permission` conditions. The field in
the power level event the user needs a minimum power level for. Fields
must be specified under the `notifications` property in the power level
event's `content`. */
    key?: string | undefined;
    /** The kind of condition to apply. See [conditions](https://spec.matrix.org/v1.5/client-server-api/#conditions) for
more information on the allowed kinds and how they work. */
    kind: string;
    /** Required for `event_match` conditions. The glob-style pattern to
match against. */
    pattern?: string | undefined;
}

export interface Conditions7 extends PushCondition7 {
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface ClientEventWithoutRoomID26 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned59 | undefined;
}

/** The format used for events when they are returned from a homeserver to a client via the Client-Server API, or sent to an Application Service via the Application Services API. */
export interface Events_after2 extends ClientEventWithoutRoomID26 {
    /** The ID of the room associated with this event. */
    room_id: string;
    unsigned?: Unsigned52 | undefined;
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface ClientEventWithoutRoomID27 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned60 | undefined;
}

/** The format used for events when they are returned from a homeserver to a client via the Client-Server API, or sent to an Application Service via the Application Services API. */
export interface Events_before2 extends ClientEventWithoutRoomID27 {
    /** The ID of the room associated with this event. */
    room_id: string;
    unsigned?: Unsigned53 | undefined;
}

export interface Anonymous121 {
    avatar_url?: string | undefined;
    displayname?: string | undefined;
}

export interface Unsigned50 {
    redacted_because?: any | undefined;
}

export interface Unsigned51 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

/** The basic set of fields all events must have. */
export interface Event7 {
    /** The fields in this object will vary depending on the type of event. When interacting with the REST API, this is the HTTP body. */
    content: any;
    /** The type of event. This SHOULD be namespaced similar to Java package naming conventions e.g. 'com.example.subdomain.event.type' */
    type: string;
}

export interface Events5 extends Event7 {
}

/** The basic set of fields all events must have. */
export interface Event8 {
    /** The fields in this object will vary depending on the type of event. When interacting with the REST API, this is the HTTP body. */
    content: any;
    /** The type of event. This SHOULD be namespaced similar to Java package naming conventions e.g. 'com.example.subdomain.event.type' */
    type: string;
}

export interface Events6 extends Event8 {
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface Events7 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned55 | undefined;
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface Events8 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned56 | undefined;
}

/** The basic set of fields all events must have. */
export interface Event9 {
    /** The fields in this object will vary depending on the type of event. When interacting with the REST API, this is the HTTP body. */
    content: any;
    /** The type of event. This SHOULD be namespaced similar to Java package naming conventions e.g. 'com.example.subdomain.event.type' */
    type: string;
}

export interface Events9 extends Event9 {
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface Events10 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned57 | undefined;
}

/** The format used for events when they are returned from API endpoints such as `/sync`, where the `room_id` is implied elsewhere in the response. */
export interface Events11 {
    /** The body of this event, as created by the client which sent it. */
    content: any;
    /** The globally unique identifier for this event. */
    event_id: string;
    /** Timestamp (in milliseconds since the unix epoch) on originating homeserver
when this event was sent. */
    origin_server_ts: number;
    /** Contains the fully-qualified ID of the user who sent this event. */
    sender: string;
    /** Present if, and only if, this event is a *state* event. The key making
this piece of state unique in the room. Note that it is often an empty
string.

State keys starting with an `@` are reserved for referencing user IDs, such
as room members. With the exception of a few events, state events set with a
given user's ID as the state key MUST only be set by that user. */
    state_key?: string | undefined;
    /** The type of the event. */
    type: string;
    /** Contains optional extra information about the event. */
    unsigned?: Unsigned58 | undefined;
}

export interface Unsigned52 {
    redacted_because?: any | undefined;
}

export interface Unsigned53 {
    redacted_because?: any | undefined;
}

export interface Unsigned54 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface Unsigned55 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface Unsigned56 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface Unsigned57 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface Unsigned58 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface Unsigned59 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface Unsigned60 {
    /** The time in milliseconds that has elapsed since the event was sent. This field is generated by the local homeserver, and may be incorrect if the local time on at least one of the two servers is out of sync, which can cause the age to either be negative or greater than it actually is. */
    age?: number | undefined;
    /** The previous `content` for this event. This field is generated
by the local homeserver, and is only returned if the event is a state event,
and the client has permission to see the previous content.
 */
    prev_content?: any | undefined;
    /** The event that redacted this event, if any. */
    redacted_because?: any | undefined;
    /** The client-supplied [transaction ID](https://spec.matrix.org/v1.5/client-server-api/#transaction-identifiers), for example, provided via
`PUT /_matrix/client/v3/rooms/{roomId}/send/{eventType}/{txnId}`,
if the client being given the event is the same one which sent it.
 */
    transaction_id?: string | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class MxApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isMxApiException = true;

    static isMxApiException(obj: any): obj is MxApiException {
        return obj.isMxApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    throw new MxApiException(message, status, response, headers, result);
}

}